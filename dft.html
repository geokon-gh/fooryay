<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Discrete Fourier Transform</title>
<meta name="generator" content="Org mode">
<meta name="author" content="George Kontsevich">
<meta name="description" content="DFT in MATLAB/Octave"
>
<link rel="stylesheet" type="text/css" href="../web/worg.css" />
<link rel="shortcut icon" href="../web/panda.svg" type="image/x-icon">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="../MathJax/MathJax.js?config=TeX-AMS_CHTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Discrete Fourier Transform</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org80c5782">Goal</a></li>
<li><a href="#org8cbb49e">Complex numbers</a>
<ul>
<li><a href="#org63bdd63">The complex plane</a></li>
</ul>
</li>
<li><a href="#orge945343">Complex number lengths</a>
<ul>
<li><a href="#org967655e">The Complex Conjugate</a></li>
<li><a href="#orgf47566f">Hermitian Transpose</a></li>
</ul>
</li>
<li><a href="#org1d21463">The Unit Circle</a></li>
<li><a href="#org39ba22d">Euler's Formula</a></li>
<li><a href="#org0ed4419">The roots of unity</a></li>
<li><a href="#org0f52056">Fourier series</a></li>
<li><a href="#org432dfd1">Fourier Vectors</a></li>
<li><a href="#orgb6e494c">Fourier Matrix</a></li>
<li><a href="#org7cf5cbf">Frequency Space?</a>
<ul>
<li><a href="#org0e19de1">How does a sinusoidal look in this basis?</a></li>
<li><a href="#org87f249d">How does a phase shift look in this basis?</a></li>
<li><a href="#org9fa562b">Which frequencies are observable?</a></li>
<li><a href="#org3e9d4a6">How does a frequency who's period isn't a whole fraction of the sample rate come out in this basis?</a></li>
</ul>
</li>
<li><a href="#org6e911dd">Amplitude Modulation</a>
<ul>
<li><a href="#orgbfcd896">Sinusoidal AM</a></li>
</ul>
</li>
<li><a href="#org5ad822b">Frequency modulation</a></li>
<li><a href="#org4f5159f">Addendum</a>
<ul>
<li><a href="#orgf72c9bb">LTI Systems</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org80c5782" class="outline-2">
<h2 id="org80c5782">Goal</h2>
<div class="outline-text-2" id="text-org80c5782">
<ul class="org-ul">
<li>The goal is to build a new orthonormal basis.</li>
</ul>
<blockquote>
<p>
Orthonormality means :
</p>
<ul class="org-ul">
<li>points in this basis aren't stretched or scaled (ie. they maintain their length/norm)</li>
<li>the basis vectors are orthogonal - so their inner product is equal to <b>0</b></li>
<li>the basis vectors are of length <b>1</b> - the inner product with themselves is <b>1</b></li>
<li>the basis will be easily invertible (through transposition)</li>
</ul>
</blockquote>

<ul class="org-ul">
<li>We leverage multiplicative properties of complex numbers to construct this basis. It will make periodic components of our input apparant and can allow us to reason about frequencies and phases of signal components.</li>

<li>The new basis allows us to carry out a class of operations that are numerically intensive in the standard basis but much quicker in the frequency-basis.</li>
</ul>
</div>
</div>

<div id="outline-container-org8cbb49e" class="outline-2">
<h2 id="org8cbb49e">Complex numbers</h2>
<div class="outline-text-2" id="text-org8cbb49e">
<p>
Complex numbers are of the form 
</p>
<blockquote>
<p>
a+ib
</p>
</blockquote>
<p>
where <b>i= &radic;(-1)</b><br>
<b>a</b> = real part
<b>b</b> = imaginary part. 
</p>
</div>

<div id="outline-container-org63bdd63" class="outline-3">
<h3 id="org63bdd63">The complex plane</h3>
<div class="outline-text-3" id="text-org63bdd63">
<p>
The pair <b>(a,b)</b> are often referred to as a point on the complex plane. 
</p>

<p>
To draw this <i>complex plane</i> we treat <b>a*/*real</b> as the <i>x</i> coordinate and <b>b*/*imaginary</b> as the <i>y</i> coordinate.
</p>

<ul class="org-ul">
<li>1. Like 2D coordinates, we can add/translate them</li>
</ul>
<blockquote>
<p>
(a+ib) + (c+id) = (a+c) + i(b+d)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">1<span style="color: #483d8b;">+</span>5i <span style="color: #483d8b;">+</span> 3<span style="color: #483d8b;">+</span>2j
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">4+7i
</pre>
</div>
<ul class="org-ul">
<li>2. And Scale them</li>
</ul>
<blockquote>
<p>
c &times; (a+ib) = ca +icb 
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">10 <span style="color: #483d8b;">*</span> (1<span style="color: #483d8b;">+</span>5i)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">10+50i
</pre>
</div>

<ul class="org-ul">
<li>3. However <b>!UNLIKE!</b> 2D [x,y] coordinates, complex numbers can be multiplied:</li>
</ul>
<blockquote>
<p>
(a+ib) &times; (c+id) = (ac-bd) + i(ad+bc)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">(1<span style="color: #483d8b;">+</span>2i) <span style="color: #483d8b;">*</span> (3<span style="color: #483d8b;">+</span>4j)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">-5+10i
</pre>
</div>

<p>
<b>Notice</b> that if we are given 2 coordinates <b>[x<sub>0</sub>,y<sub>0</sub>]</b> and <b>[x<sub>1</sub>,y<sub>1</sub>]</b> we never ask ourselves to multiple them because multiplication between two points is simply no a defined operation. Just like how you don't ever multiple two points on a map. 
</p>

<p>
However in the complex-number case this operation comes naturally and it generates a new complex number!
</p>

<blockquote>
<p>
Note: You can do a dot and cross product between two [x,y] coordinates but:
</p>
<ul class="org-ul">
<li>[x<sub>0</sub>,y<sub>0</sub>] &bull; [x<sub>1</sub>,y<sub>1</sub>] &rarr; <i>scalar</i></li>
<li>[x<sub>0</sub>,y<sub>0</sub>] &times; [x<sub>1</sub>,y<sub>1</sub>] &rarr; <i>requires an extra <code>z</code> dimension</i></li>
</ul>
</blockquote>

<p>
So it's important to stress that points in the complex plane have this extra "feature" so you can't stretch the 2D coordinate interpretation too far. While adding two complex numbers can be visualized by putting the two vectors end-to-end - there is no equivalent visualization for a product in the general case (as far as I can tell). You can try multiplying arbitrary vectors and see that the result seems to point in a new direction.
</p>
</div>
</div>
</div>

<div id="outline-container-orge945343" class="outline-2">
<h2 id="orge945343">Complex number lengths</h2>
<div class="outline-text-2" id="text-orge945343">
<p>
Just like real number, points and vectors, complex numbers have a "length" or magnitude
</p>
<blockquote>
<p>
&vert;a+ib&vert; = &radic;(a<sup>2</sup>+b<sup>2</sup>}
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">abs(3<span style="color: #483d8b;">+</span>4i)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">5
</pre>
</div>

<p>
And just a real number (and later vectors) this norm is a real scalar value <br>
</p>

<p>
One easy way to avoid absolute values when getting the magnitude of a real value is to square the value <b>a<sup>2</sup>=|a|<sup>2</sup></b> 
</p>
</div>

<div id="outline-container-org967655e" class="outline-3">
<h3 id="org967655e">The Complex Conjugate</h3>
<div class="outline-text-3" id="text-org967655e">
<p>
Notice that in the complex case the square of the magnitude can be calculated directly with:
</p>
<blockquote>
<p>
a<sup>2</sup>+b<sup>2</sup> = (a+ib)(a-ib)
</p>
</blockquote>
<p>
The <b>a-ib</b> is known as the <b>complex conjugate</b> of <b>a+ib</b>
</p>
<div class="org-src-container">
<pre class="src src-octave">conj(3<span style="color: #483d8b;">+</span>4j)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">3-4i
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> 3<span style="color: #483d8b;">+</span>4i
v<span style="color: #483d8b;">*</span>conj(v)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">25
</pre>
</div>

<p>
What's convenient about this way of getting the square of the magnitude is that is keeps working for real values. Since a real value <b>a</b> can be written as the complex number <b>a+i0</b> we can write its complex conjugate as <b>a-i0</b> and see that its norm is
</p>
<blockquote>
<p>
a<sup>2</sup>+0<sup>2</sup> = (a+i0)(a-i0) = a<sup>2</sup>
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> 3
v<span style="color: #483d8b;">*</span>conj(v)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">9
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf47566f" class="outline-3">
<h3 id="orgf47566f">Hermitian Transpose</h3>
<div class="outline-text-3" id="text-orgf47566f">
<p>
To get lengths of 2D,3D,etc. points we use the inner product. It's like Pythagoras' Theorem except you leave the end result squared..
</p>
<blockquote>
<p>
v &middot; v<sup>T</sup><br>
= [a b c d] &middot; [a b c d]<sup>T</sup><br>
= a<sup>2</sup> + b<sup>2</sup> + c<sup>2</sup> + d<sup>2</sup>
</p>
</blockquote>
<p>
If we try to carry out the same operation using complex values for the vector elements, even in the <b>1x1</b> case we'd get a weird value
</p>
<blockquote>
<p>
z*z<sup>T</sup>=z<sup>2</sup>=(a+ib)<sup>2</sup>=a<sup>2</sup>+i2ab-b<sup>2</sup>
</p>
</blockquote>
<p>
this is a non-real value and doesn't match our understanding of length. So using the transpose to do an inner product with complex values doesn't give you a magnitude as before. 
</p>

<p>
But using complex conjugates in the transpose (a Hermitian transpose)  "fixes" the inner product
</p>
<blockquote>
<p>
[a+ib c+id]<sup>*</sup> = [a-ib c-d]<sup>T</sup>
</p>

<p>
[a+ib c+id][a+ib c+id]<sup>*</sup> = [(a<sup>2</sup>+b<sup>2</sup>)   (c<sup>2</sup>+d<sup>2</sup>)]<sup>T</sup>
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> [3<span style="color: #483d8b;">+</span>4i 6<span style="color: #483d8b;">+</span>8i]
v<span style="color: #483d8b;">'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 3-4i |</span>
<span style="color: #0000ff;">| 6-8i |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">v<span style="color: #483d8b;">*</span>v<span style="color: #483d8b;">'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">125
</pre>
</div>

<p>
Since the final value is <i>always</i> scalar/real:
</p>
<blockquote>
<p>
ab<sup>*</sup> = (ab<sup>*</sup>)<sup>*</sup> = a<sup>*</sup>b
</p>
</blockquote>
<ul class="org-ul">
<li></li>
</ul>
<p>
This means that either <b>a</b> or <b>b</b> can be conjugated when you want to do an inner product of two complex values
</p>

<p>
And again, when the vector values are all <i>real</i> the Hermetian transpose will behave exactly like a "normal" transpose - so the Hermitian transpose makes the standard transpose redundant
</p>
</div>
</div>
</div>

<div id="outline-container-org1d21463" class="outline-2">
<h2 id="org1d21463">The Unit Circle</h2>
<div class="outline-text-2" id="text-org1d21463">
<p>
Note the obvious statement that that when a number or vector is of length one then the square of its magnitude is also equal to <b>1</b>. All these special points of length <b>1</b> lie on what's called the <i>unit cirle</i>. 
</p>

<p>
If we start with two complex numbers <b>a+ib</b> and <b>c+id</b> on the unit circle we can write
</p>
<blockquote>
<p>
(a<sup>2</sup>+b<sup>2</sup>)<sup>&frac12;</sup> = 1<br>
a<sup>2</sup>+b<sup>2</sup> = 1<br>
(c<sup>2</sup>+d<sup>2</sup>)<sup>&frac12;</sup> = 1<br>
c<sup>2</sup>+d<sup>2</sup> = 1
</p>
</blockquote>
<p>
As we saw, their product is the point <b>(ac-bd) + i(ad+bc)</b>.<br>
When we calculate the length of the product it also turns out to be <b>1</b>:
</p>
<blockquote>
<p>
[ (ac-bd)<sup>2</sup> + (ad+bc)<sup>2</sup> ]<sup>&frac12;</sup><br>
[ a<sup>2</sup>c<sup>2</sup> - 2acbd + b<sup>2</sup>d<sup>2</sup> + a<sup>2</sup>d<sup>2</sup> + 2adbc + b<sup>2</sup>c<sup>2</sup> ]<sup>&frac12;</sup><br>
[ a<sup>2</sup>c<sup>2</sup> + b<sup>2</sup>b<sup>2</sup> + a<sup>2</sup>d<sup>d</sup> + b<sup>2</sup>c<sup>2</sup> ]<sup>&frac12;</sup><br>
[ c<sup>2</sup>(a<sup>2</sup> + b<sup>2</sup>) + d<sup>2</sup>(a<sup>2</sup> + b<sup>2</sup>) ]<sup>(&frac12;)</sup>
</p>
</blockquote>
<p>
(last step is subsituting the previous equalities in to see it's equal to <b>1</b>)
</p>

<p>
This tells us that while in the general case the complex product is hard to visualize, we know that at least the product of any two points on the unit circle gives us a new point on the unit circle. 
</p>
<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> sqrt(0.2)<span style="color: #483d8b;">+</span>sqrt(0.8)<span style="color: #483d8b;">*</span>i
w <span style="color: #483d8b;">=</span> sqrt(0.69)<span style="color: #483d8b;">+</span>sqrt(0.31)<span style="color: #483d8b;">*</span>i
abs(v<span style="color: #483d8b;">*</span>w)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">0.9999999999999999
</pre>
</div>

<p>
This is often described as a <i>rotation</i> of the point on the <i>unit circle</i>
</p>
</div>
</div>
<div id="outline-container-org39ba22d" class="outline-2">
<h2 id="org39ba22d">Euler's Formula</h2>
<div class="outline-text-2" id="text-org39ba22d">
<p>
To make the multiplicative rotations more natural we would like to start describing the points in terms of polar coordinates. The general conversion to polar coordinates is straightforward:
</p>
<blockquote>
<p>
radius = r = (a<sup>2</sup>+b<sup>2</sup>)<sup>1/2</sup><br>
angle = &theta; = atan(b/a)
</p>
</blockquote>
<p>
Going back is also easy
</p>
<blockquote>
<p>
a = rcos(&theta;)<br>
b = rsin(&theta;)
</p>
</blockquote>
<p>
So any complex number <b>z=a+ib</b>, through substitution, can be rewritten into a mathematically equivalent form using <b>r</b> and <b>&theta;</b>:
</p>
<blockquote>
<p>
z = rcos(&theta;) + irsin(&theta;)
</p>
</blockquote>
<p>
However a more compact representation of this is given by <b>Euler's formula</b>:
</p>
<blockquote>
<p>
re<sup>i&theta;</sup>=rcos(&theta;)+irsin(&theta;)
</p>
</blockquote>

<p>
A complete proof of this identity is a bit long, but the steps are:
</p>
<ol class="org-ol">
<li>Show that the derivative of <b>e<sup>x</sup></b> is <b>e<sup>x</sup></b> (it's the only equation of the form <b>a<sup>x</sup></b> that have this "stable" property). Note how the derivatives of <b>sin</b> and <b>cos</b> have a similar property..</li>
<li>Using the chain rule we see that the <b>n<sup>th</sup></b> derivative of <b>e<sup>ix</sup></b> will be equal to <b>i<sup>n</sup>e<sup>ix</sup></b></li>
<li><b>i<sup>n</sup></b> is a cyclic function with half its terms imaginary and half real</li>
<li>We then describe <b>e<sup>i&theta;</sup></b> around <b>0</b> in terms of the <i>Taylor/Maclaurin Series</i> - In so doing we avoid having to directly explain what is an imaginary exponent..</li>
<li>Half the terms of the Taylor/Maclaurin Series will be imaginary (odd <b>n</b> powers) and half real (even <b>n</b> powers)</li>
<li>The real terms will match the Maclaurin Series of a cosine function and the imaginary will match those of the sine function</li>
</ol>

<p>
The proof isn't super satisfying since there is no real way to visualize an imaginary power
</p>

<div class="org-src-container">
<pre class="src src-octave">123<span style="color: #483d8b;">*</span>exp(i<span style="color: #483d8b;">*</span>0.321)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">116.7172063656597+38.80842354690544i
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">123<span style="color: #483d8b;">*</span>cos(0.321)<span style="color: #483d8b;">+</span>i<span style="color: #483d8b;">*</span>123<span style="color: #483d8b;">*</span>sin(0.321)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">116.7172063656597+38.80842354690544i
</pre>
</div>

<p>
And since <i>sine</i> and <i>cosine</i> are cyclical, so are the real and imaginary components of <b>re<sup>i&theta;</sup></b>
</p>
<div class="org-src-container">
<pre class="src src-octave">x <span style="color: #483d8b;">=</span> [0<span style="color: #483d8b;">:</span>0.01<span style="color: #483d8b;">:</span>2<span style="color: #483d8b;">*</span>pi]
y <span style="color: #483d8b;">=</span> exp(j<span style="color: #483d8b;">.*</span>x)
plot(x<span style="color: #483d8b;">,</span>real(y))
line(x<span style="color: #483d8b;">,</span>imag(y))
hold on<span style="color: #483d8b;">;</span>
axis <span style="color: #8b2252;">"off"</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"euler-sin-cos.svg"</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="./euler-sin-cos.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
Using the trigonometric properties (which are self evident if you think of the graph and even/odd functions)
</p>
<blockquote>
<p>
sin(-&theta;)=-sin(&theta;)<br>
cos(-&theta;)= cos(&theta;)
</p>
</blockquote>
<p>
We can rewrite the complex conjugate as
</p>
<blockquote>
<p>
a - ib<br>
r cos(&theta;) - <i>i</i> r sin(&theta;)<br>
r cos(-&theta;) + <i>i</i> r sin{-&theta;) = <b>re<sup>-&theta;</sup></b>
</p>
</blockquote>

<p>
As we just saw in the previous section, the radius in the products of points on the unit cirle is always equal to one. so a polar coordinate system will bring the problem down from 2 variables, <b>a</b> and <b>b</b>, to just one constant <i>radius</i> <b>r</b> of size <i>1</i> and one variable <i>angle</i> <b>&theta;</b>. The points on the unit circle can all be written down as:
</p>
<blockquote>
<p>
e<sup>i&theta;</sup>
</p>
</blockquote>
<p>
And we can say the magnitude of the product of two of these is always equal to <i>1</i>
</p>
<blockquote>
<p>
&shy; || e<sup><i>i</i>&theta;</sup> * e<sup><i>i</i>&omega;</sup> || = || e<sup><i>i</i>&shy;(&theta;+&omega;)</sup> || = 1
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">abs(exp(i<span style="color: #483d8b;">*</span>0.345)<span style="color: #483d8b;">*</span>exp(i<span style="color: #483d8b;">*</span>1.789))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">1
</pre>
</div>

<p>
Now notice that if <b>&omega;= 2&pi; - &theta;</b> that:
</p>
<blockquote>
<p>
e<sup> <i>i</i> (&theta;+&omega;)</sup> = e<sup> <i>i</i> 2&pi;</sup> = cos(2&pi;) + <i>i</i> sin(2&pi;) = 1 + <i>i</i> 0 = 1
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">exp(i<span style="color: #483d8b;">*</span>2<span style="color: #483d8b;">*</span>pi)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">1-2.449293598294706e-16i
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ed4419" class="outline-2">
<h2 id="org0ed4419">The roots of unity</h2>
<div class="outline-text-2" id="text-org0ed4419">
<p>
Furthermore if <b>&alpha;=2&pi;/n</b> then:
</p>
<blockquote>
<p>
[e<sup>i&alpha;</sup>]<sup>n</sup> = e<sup>in&alpha;</sup> = e<sup>i2&pi;</sup> = 1
</p>
</blockquote>
<p>
This tells us that taking the n<sup>th</sup> root of number <b>1</b> more solutions than just <b>1</b> (and <b>-1</b> for even <i>n</i>'s). It also has additional  complex numbers solution!
</p>
<blockquote>
<p>
1<sup>1/n</sup> = e<sup>i2&pi;/n</sup>
</p>
</blockquote>
<p>
The typical notation here is to say 
</p>
<blockquote>
<p>
&xi;<sub>n</sub> = e<sup>-i2&pi;/n</sup> = cos(2&pi;/n) + isin(2&pi;/n)<br>
&xi;<sub>n</sub><sup>n</sup>=1
</p>
</blockquote>
<p>
This <b>&xi;<sub>n</sub></b> is called the <b>n<sup>th</sup> root of unity</b> (<b>Note</b>: I've added the subscript <b>n</b> for clarity - though it's usually omitted)
</p>
<div class="org-src-container">
<pre class="src src-octave"><span style="color: #a020f0;">function</span> res <span style="color: #483d8b;">=</span> <span style="color: #0000ff;">rootOfUnity</span>(n)
  res <span style="color: #483d8b;">=</span> exp(i<span style="color: #483d8b;">*</span>2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">./</span>n)<span style="color: #483d8b;">;</span>
<span style="color: #a020f0;">end</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-octave">n <span style="color: #483d8b;">=</span> 7<span style="color: #483d8b;">;</span>
nThRootOfUnity <span style="color: #483d8b;">=</span> rootOfUnity(n)<span style="color: #483d8b;">;</span>
ans <span style="color: #483d8b;">=</span> nThRootOfUnity
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">0.6234898018587336+0.7818314824680298i
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">nThRootOfUnity<span style="color: #483d8b;">^</span>n
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">1-4.996003610813204e-16i
</pre>
</div>


<div class="org-src-container">
<pre class="src src-octave">scatter(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n<span style="color: #483d8b;">,</span> real(nThRootOfUnity)<span style="color: #483d8b;">,</span>color<span style="color: #483d8b;">='</span>b<span style="color: #483d8b;">'</span>)<span style="color: #483d8b;">;</span>
scatter(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n<span style="color: #483d8b;">,</span> imag(nThRootOfUnity)<span style="color: #483d8b;">,</span>color<span style="color: #483d8b;">='</span>r<span style="color: #483d8b;">'</span>)<span style="color: #483d8b;">;</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"one-nth-root.svg"</span><span style="color: #483d8b;">;</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="./one-nth-root.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Now we again can see the cyclicity:
</p>
<blockquote>
<p>
&xi;<sub>n</sub><sup>n+j</sup> = &xi;<sub>n</sub><sup>n</sup>&times;&xi;<sub>n</sub><sup>j</sup> = &xi;<sub>n</sub><sup>j</sup><br>
&xi;<sub>n</sub><sup>nk</sup> = [&xi;<sub>n</sub><sup>n</sup>]<sup>k</sup> = [e<sup>-i2&pi;</sup>]<sup>k</sup> = 1<sup>k</sup> = 1
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">k <span style="color: #483d8b;">=</span> n<span style="color: #483d8b;">;</span>
kPowersOfTheNthRoot <span style="color: #483d8b;">=</span> nThRootOfUnity<span style="color: #483d8b;">.^</span>[0<span style="color: #483d8b;">:</span>k]<span style="color: #483d8b;">;</span>
scatter((2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n)<span style="color: #483d8b;">.*</span>[0<span style="color: #483d8b;">:</span>k]<span style="color: #483d8b;">,</span> real(kPowersOfTheNthRoot)<span style="color: #483d8b;">,</span>color<span style="color: #483d8b;">='</span>b<span style="color: #483d8b;">'</span>)<span style="color: #483d8b;">;</span>
scatter((2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n)<span style="color: #483d8b;">.*</span>[0<span style="color: #483d8b;">:</span>k]<span style="color: #483d8b;">,</span> imag(kPowersOfTheNthRoot)<span style="color: #483d8b;">,</span>color<span style="color: #483d8b;">='</span>r<span style="color: #483d8b;">'</span>)<span style="color: #483d8b;">;</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"k-nth-root.svg"</span><span style="color: #483d8b;">;</span>
hold off<span style="color: #483d8b;">;</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="./k-nth-root.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-org0f52056" class="outline-2">
<h2 id="org0f52056">Fourier series</h2>
<div class="outline-text-2" id="text-org0f52056">
<p>
The Fourier series is a very special sum of the exponents of an n<sup>th</sup> root of unity : <b>&xi;<sub>n</sub></b><br>
</p>
<blockquote>
<p>
1 + &xi;<sub>n</sub><sup>k</sup> + &xi;<sub>n</sub><sup>2k</sup> + &#x2026; + &xi;<sub>n</sub><sup>(n-2)k</sup> + &xi;<sub>n</sub><sup>(n-1)k</sup>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave"><span style="color: #a020f0;">function</span> res <span style="color: #483d8b;">=</span> <span style="color: #0000ff;">fourierSeries</span>(n<span style="color: #483d8b;">,</span>k)
  res <span style="color: #483d8b;">=</span> rootOfUnity(n)<span style="color: #483d8b;">.^</span>((0<span style="color: #483d8b;">:</span>(n<span style="color: #483d8b;">-</span>1))<span style="color: #483d8b;">*</span>k)<span style="color: #483d8b;">;</span>
<span style="color: #a020f0;">end</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-octave">ans<span style="color: #483d8b;">=</span>disp(fourierSeries(5<span style="color: #483d8b;">,</span>3)<span style="color: #483d8b;">.'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1.00000 + 0.00000i  |</span>
<span style="color: #0000ff;">| -0.80902 - 0.58779i |</span>
<span style="color: #0000ff;">| 0.30902 + 0.95106i  |</span>
<span style="color: #0000ff;">| 0.30902 - 0.95106i  |</span>
<span style="color: #0000ff;">| -0.80902 + 0.58779i |</span>
<span style="color: #0000ff;">|                     |</span>
</pre>
</div>
<p>
We will see that no matter the what integer value is choosen for <b>k</b> - the sum will be equal to <b>0</b>.
</p>

<p>
Start by noticing that this sum when multiplied by <b>&xi;<sub>n</sub><sup>k</sup></b> gives the same sequence back. The last term goes to <b>&xi;<sub>n</sub><sup>nk</sup> = =[&xi;<sub>n</sub><sup>n</sup>]<sup>k</sup> = 1<sup>k</sup> = 1</b> and the remaining terms in effect shift places giving us:
</p>
<blockquote>
<p>
&xi;<sub>n</sub><sup>k</sup> + &xi;<sub>n</sub><sup>2k</sup> + &xi;<sub>n</sub><sup>3k</sup> + &#x2026; + &xi;<sub>n</sub><sup>(n-1)k</sup> + 1
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">n<span style="color: #483d8b;">=</span>5<span style="color: #483d8b;">,</span>k<span style="color: #483d8b;">=</span>3
ans<span style="color: #483d8b;">=</span>disp((fourierSeries(n<span style="color: #483d8b;">,</span>k)<span style="color: #483d8b;">.*</span>(rootOfUnity(n)<span style="color: #483d8b;">^</span>k))<span style="color: #483d8b;">.'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| -0.80902 - 0.58779i |</span>
<span style="color: #0000ff;">| 0.30902 + 0.95106i  |</span>
<span style="color: #0000ff;">| 0.30902 - 0.95106i  |</span>
<span style="color: #0000ff;">| -0.80902 + 0.58779i |</span>
<span style="color: #0000ff;">| 1.00000 - 0.00000i  |</span>
<span style="color: #0000ff;">|                     |</span>
</pre>
</div>

<p>
So we can write
</p>
<ul class="org-ul">
<li>&xi;<sub>n</sub><sup>k</sup> * <i>fourier-series</i> = <i>fourier-series</i></li>
</ul>
<p>
Therefore
</p>
<ul class="org-ul">
<li>&xi;<sub>n</sub><sup>k</sup> * <i>fourier-series</i> - <i>fourier-series</i> = 0</li>
<li><i>fourier-series</i> * (&xi;<sub>n</sub><sup>k</sup> - 1) = 0</li>
</ul>
<p>
And therefore.. 
</p>
<ul class="org-ul">
<li><i>fourier-series</i>  = 0</li>
</ul>
<p>
.. or to write it out again in full form - for all integer values of <i>k</i>
</p>
<blockquote>
<p>
1+&xi;<sub>n</sub><sup>k</sup>+&xi;<sub>n</sub><sup>2k</sup>+&#x2026;+&xi;<sub>n</sub><sup>(n-2)k</sup>+&xi;<sub>n</sub><sup>(n-1)k</sup> = 0
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">n<span style="color: #483d8b;">=</span>7<span style="color: #483d8b;">,</span>k<span style="color: #483d8b;">=</span>1
sum(fourierSeries(n<span style="color: #483d8b;">,</span>k))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">-3.33066907387547e-16
</pre>
</div>
</div>
</div>

<div id="outline-container-org432dfd1" class="outline-2">
<h2 id="org432dfd1">Fourier Vectors</h2>
<div class="outline-text-2" id="text-org432dfd1">
<p>
Not immediately apparant, but it turns out that the Fourier series terms, when places in a vector with different values of <b>k</b>, form mutually orthogonal vectors
</p>

<p>
Here I choose <b>r</b> and <b>s</b> for two arbitrary values of <b>k</b> and carry out the Hermitian inner product:
</p>
<blockquote>
<p>
[ 1 &xi;<sup>r</sup> &xi;<sup>2r</sup> &#x2026; &xi;<sup>(n-1)r</sup> ] [ 1 &xi;<sup>s</sup> &xi;<sup>2s</sup> &#x2026; &xi;<sup>(n-1)s</sup> ]<sup>*</sup> <br>
[ 1 &xi;<sup>r</sup> &xi;<sup>2r</sup> &#x2026; &xi;<sup>(n-1)r</sup> ] [ 1 &xi;<sup>-s</sup> &xi;<sup>-2s</sup> &#x2026; &xi;<sup>-(n-1)s</sup> ]<sup>T</sup> <br>
1&times;1 + &xi;<sup>r</sup>&xi;<sup>-s</sup> + &xi;<sup>2r</sup>&xi;<sup>-2s</sup> + &#x2026; + &xi;<sup>(n-2)r</sup>&xi;<sup>-(n-2)s</sup> + &xi;<sup>(n-1)r</sup>&xi;<sup>-(n-1)s</sup> <br>
1 + &xi;<sup>r-s</sup> + &xi;<sup>2(r-s)</sup> + &#x2026; + &xi;<sup>(n-2)(r-s)</sup> + &xi;<sup>(n-1)(r-s)</sup>
</p>
</blockquote>

<p>
The resulting <b>r-s</b>'s in the exponent are effectively just another value of <b>k</b> - and we know the sum of a Fourier series with any <b>k</b> is equal to <b>0</b>
</p>

<p>
The exception is when <b>r=s</b>:
</p>
<blockquote>
<p>
[ 1 &xi;<sup>k</sup> &xi;<sup>2k</sup> &#x2026; &xi;<sup>(n-1)k</sup> ]  [ 1 &xi;<sup>k</sup> &xi;<sup>2k</sup> &#x2026; &xi;<sup>(n-1)k</sup> ]<sup>*</sup> <br>
1&times;1 + &xi;<sup>k</sup>&times;&xi;<sup>-k</sup> + &xi;<sup>2k</sup>&times;&xi;<sup>-2k</sup> + &#x2026; + &xi;<sup>(n-1)k</sup>&times;&xi;<sup>-(n-1)k</sup> <br>
1 + &xi;<sup>0</sup> + &xi;<sup>0</sup> + &#x2026; + &xi;<sup>0</sup> <br>
1 + 1 + 1 + &#x2026; + 1 = n
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">r<span style="color: #483d8b;">=</span>7<span style="color: #483d8b;">,</span> s<span style="color: #483d8b;">=</span>13<span style="color: #483d8b;">,</span> n<span style="color: #483d8b;">=</span> 11
fourierSeries(n<span style="color: #483d8b;">,</span>r)<span style="color: #483d8b;">*</span>fourierSeries(n<span style="color: #483d8b;">,</span>s)<span style="color: #483d8b;">'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">-2.331468351712829e-15
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">r<span style="color: #483d8b;">=</span>7<span style="color: #483d8b;">,</span> s<span style="color: #483d8b;">=</span>7<span style="color: #483d8b;">,</span> n<span style="color: #483d8b;">=</span> 11
fourierSeries(n<span style="color: #483d8b;">,</span>r)<span style="color: #483d8b;">*</span>fourierSeries(n<span style="color: #483d8b;">,</span>s)<span style="color: #483d8b;">'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">11.00000000000002
</pre>
</div>

<p>
You could also just view the <b>r=s</b> case as the inner product of a the vector with itself. Or also as the length of the vector squared. Each term is the magnitude of each Euler exponent and they're on the unit cirlce - so their lengths will always be <b>1</b>. There are <b>n</b> terms and each one is now necessarily of length <b>1</b>. So the sum will always be <b>n</b> no matter what <b>k</b> is choosen - therefore the 2-norm/length of all fourier vectors, reglardless of <b>k</b> is <b>&radic;n</b>
</p>

<p>
<b>Note</b>: that if you drop all the complex terms none of this works! You can't construct mutually orthogonal vectors out of purely real sine/cosine waves
</p>
</div>
</div>

<div id="outline-container-orgb6e494c" class="outline-2">
<h2 id="orgb6e494c">Fourier Matrix</h2>
<div class="outline-text-2" id="text-orgb6e494c">
<p>
We've just shown that the fourier vectors are orthogonal as long as the <i>k</i>'s are different. The only caveat is that when <i>k=n</i> then the result is identical to <i>k=0</i> and when <i>k=n+1</i> it's identical to <i>k=1</i> .. etc. So there are actually only <i>n</i> distinct fourier vectors. The next step is self evident. We just choose take the <i>n</i> distinct vectors and slap them together into a fourier matrix <b>F</b> and end up withh an orthogonal basis:<br>
<b>F</b> =
</p>
<blockquote>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&xi;</td>
<td class="org-left">&xi;<sup>2</sup></td>
<td class="org-left">&xi;<sup>3</sup></td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&xi;<sup>2</sup></td>
<td class="org-left">&xi;<sup>4</sup></td>
<td class="org-left">&xi;<sup>6</sup></td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&xi;<sup>3</sup></td>
<td class="org-left">&xi;<sup>6</sup></td>
<td class="org-left">&xi;<sup>9</sup></td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&xi;<sup>n-1</sup></td>
<td class="org-left">&xi;<sup>n-2</sup></td>
<td class="org-left">&#x2026;</td>
<td class="org-left">..</td>
</tr>
</tbody>
</table>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave"><span style="color: #a020f0;">function</span> F <span style="color: #483d8b;">=</span> <span style="color: #0000ff;">fourierMatrix</span>(n)
  F<span style="color: #483d8b;">=</span>zeros(n<span style="color: #483d8b;">,</span>0)<span style="color: #483d8b;">;</span>
  <span style="color: #a020f0;">for</span> k <span style="color: #483d8b;">=</span> 0<span style="color: #483d8b;">:</span>(n<span style="color: #483d8b;">-</span>1)
    F<span style="color: #483d8b;">=</span>horzcat(F<span style="color: #483d8b;">,</span>fourierSeries(n<span style="color: #483d8b;">,</span>k)<span style="color: #483d8b;">.'</span>)<span style="color: #483d8b;">;</span>
  <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">n <span style="color: #483d8b;">=</span> 7<span style="color: #483d8b;">;</span>
F <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">;</span>
round(F<span style="color: #483d8b;">.*</span>1000)<span style="color: #483d8b;">./</span>1000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1+0i | 1+0i          | 1+0i          | 1+0i          | 1+0i          | 1+0i          | 1+0i          |</span>
<span style="color: #0000ff;">| 1+0i | 0.623+0.782i  | -0.223+0.975i | -0.901+0.434i | -0.901-0.434i | -0.223-0.975i | 0.623-0.782i  |</span>
<span style="color: #0000ff;">| 1+0i | -0.223+0.975i | -0.901-0.434i | 0.623-0.782i  | 0.623+0.782i  | -0.901+0.434i | -0.223-0.975i |</span>
<span style="color: #0000ff;">| 1+0i | -0.901+0.434i | 0.623-0.782i  | -0.223+0.975i | -0.223-0.975i | 0.623+0.782i  | -0.901-0.434i |</span>
<span style="color: #0000ff;">| 1+0i | -0.901-0.434i | 0.623+0.782i  | -0.223-0.975i | -0.223+0.975i | 0.623-0.782i  | -0.901+0.434i |</span>
<span style="color: #0000ff;">| 1+0i | -0.223-0.975i | -0.901+0.434i | 0.623+0.782i  | 0.623-0.782i  | -0.901-0.434i | -0.223+0.975i |</span>
<span style="color: #0000ff;">| 1+0i | 0.623-0.782i  | -0.223-0.975i | -0.901-0.434i | -0.901+0.434i | -0.223+0.975i | 0.623+0.782i  |</span>
</pre>
</div>

<p>
Looking at the real components of the columns - there is one constant component (the first column) and then <i>n</i> samples of the <i>cosine</i> function over one oscillation for the second column, <i>n</i> samples over 2 periods for the 3rd column, <i>n</i> samples over 3 periods.. etc. <br>
&real;(<b>F</b>) =
</p>
<blockquote>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">cos(1*2&pi;/n)</td>
<td class="org-left">cos(2*2&pi;/n)</td>
<td class="org-left">cos(3*2&pi;/n\)</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">cos(2*2&pi;/n)</td>
<td class="org-left">cos(4*2&pi;/n)</td>
<td class="org-left">cos(6*2&pi;/n)</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">cos(3*2&pi;/n)</td>
<td class="org-left">cos(6*2&pi;/n)</td>
<td class="org-left">cos(9*2&pi;/n)</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">cos([n-1]*2&pi;/n)</td>
<td class="org-left">cos(2[n-1]2&pi;/n)</td>
<td class="org-left">cos(3[n-1]*2&pi;/n)</td>
<td class="org-left">..</td>
</tr>
</tbody>
</table>
</blockquote>

<p>
If your input is over 1 second then this maps to a sampled cosine function of 1Hz, 2Hz, 3Hz, etc..<br>
</p>
<div class="org-src-container">
<pre class="src src-octave">realF <span style="color: #483d8b;">=</span> real(F)<span style="color: #483d8b;">;</span>
round(realF<span style="color: #483d8b;">.*</span>1000)<span style="color: #483d8b;">./</span>1000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 |      1 |      1 |      1 |      1 |      1 |      1 |</span>
<span style="color: #0000ff;">| 1 |  0.623 | -0.223 | -0.901 | -0.901 | -0.223 |  0.623 |</span>
<span style="color: #0000ff;">| 1 | -0.223 | -0.901 |  0.623 |  0.623 | -0.901 | -0.223 |</span>
<span style="color: #0000ff;">| 1 | -0.901 |  0.623 | -0.223 | -0.223 |  0.623 | -0.901 |</span>
<span style="color: #0000ff;">| 1 | -0.901 |  0.623 | -0.223 | -0.223 |  0.623 | -0.901 |</span>
<span style="color: #0000ff;">| 1 | -0.223 | -0.901 |  0.623 |  0.623 | -0.901 | -0.223 |</span>
<span style="color: #0000ff;">| 1 |  0.623 | -0.223 | -0.901 | -0.901 | -0.223 |  0.623 |</span>
</pre>
</div>

<p>
You will notice that there is a symmetry around the middle diagonal and higher frequencies look identical to lower frequencies (and hence the real values on their own don't form an orthogonal basis) This is simply because of trigonometry:
</p>
<blockquote>
<p>
&xi;<sup>n-k</sup><br>
= cos((n-k)(2&pi;/n) + i sin((n-k)(2&pi;/n) <br>
= cos(2&pi;-2&pi;k/n) + i sin(2&pi;-2&pi;k/n)
</p>
</blockquote>
<p>
b/c <b>sin(2&pi;+x)=sin(x)</b> we simplify further
</p>
<blockquote>
<p>
= cos(-2&pi;k/n) + i sin(-2&pi;k/n) <br>
= cos((k)2&pi;/n) - i sin((k)2&pi;/n) <br>
</p>
</blockquote>
<p>
So<br>
<b>&real;(&xi;<sup>n-k</sup>) = &real;(&xi;<sup>k</sup>)</b>
</p>

<p>
The complex numbers are similarly not orthogonal, just the <b>n-k<sup>th</sup></b> column is the negative of the <b>k<sup>th</sup>/</b> column
</p>

<p>
<b>&image;(&xi;<sup>n-k</sup>) = -&image;(&xi;<sup>k</sup>)</b>
</p>

<p>
Since each Fourier vector (irrespective of the <b>k</b> exponent) has length <b>&radic;n</b> (remember that the self-inner norms equal <b>n</b>), all the columns of <b>F</b> can be normalized in one go by dividing the matrix by <b>&radic;n</b>. The resulting matrix <b>(1/&radic;n)F</b> is now even better b/c it's orthonormal/unitary. Therefore its inverse is just its Hermitian transpose.
</p>
<blockquote>
<p>
[(1/&radic;n)F]<sup>-1</sup> = [(1/&radic;n)F]<sup>*</sup> <br>
F<sup>-1</sup> = (1/n)F<sup>*</sup>
</p>
</blockquote>
<p>
The inverse is easily verified.. The <b>F<sup>-1</sup>F</b> diagonal elements will be self-inner products of the columns, ie. column magnitudes, which have been normalized to unit length (<b>1</b>). And the off diagonal elements will be inner products of orthogonal vectors and therefore <b>0</b> - so the product will give us the identity matrix <b>I</b>
</p>

<div class="org-src-container">
<pre class="src src-octave">normalizedF <span style="color: #483d8b;">=</span> F<span style="color: #483d8b;">./</span>sqrt(n) <span style="color: #b22222;">%Normalize the Fourier matrix</span>
I <span style="color: #483d8b;">=</span> normalizedF<span style="color: #483d8b;">*</span>normalizedF<span style="color: #483d8b;">'</span>
real(round(I<span style="color: #483d8b;">.*</span>1000)<span style="color: #483d8b;">./</span>1000) <span style="color: #b22222;">% a bit of rounding...</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0 | 0 | 0 | 0 | 0 | 0 |</span>
<span style="color: #0000ff;">| 0 | 1 | 0 | 0 | 0 | 0 | 0 |</span>
<span style="color: #0000ff;">| 0 | 0 | 1 | 0 | 0 | 0 | 0 |</span>
<span style="color: #0000ff;">| 0 | 0 | 0 | 1 | 0 | 0 | 0 |</span>
<span style="color: #0000ff;">| 0 | 0 | 0 | 0 | 1 | 0 | 0 |</span>
<span style="color: #0000ff;">| 0 | 0 | 0 | 0 | 0 | 1 | 0 |</span>
<span style="color: #0000ff;">| 0 | 0 | 0 | 0 | 0 | 0 | 1 |</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7cf5cbf" class="outline-2">
<h2 id="org7cf5cbf">Frequency Space?</h2>
<div class="outline-text-2" id="text-org7cf5cbf">
<p>
We constructed a very convenient basis that's easily invertible and independent of the input and we can now easily move to the basis and back but it's not exactly what one would imagine as "frequency space" and a few things are unresolved
</p>
</div>

<div id="outline-container-org0e19de1" class="outline-3">
<h3 id="org0e19de1">How does a sinusoidal look in this basis?</h3>
<div class="outline-text-3" id="text-org0e19de1">
<p>
If we can carefully pair these Euler exponents we can express a real sine/cosine function:
</p>
<blockquote>
<p>
[e<sup>i&theta;</sup> + e<sup>-i&theta;</sup>]/2 = [cos(&theta;) + isin(&theta;) + cos(-&theta;) + isin(-&theta;)]/2 = <b>cos(&theta;)</b> <br>
[e<sup>i&theta;</sup> - e<sup>-i&theta;</sup>]/2i = [cos(&theta;) + isin(&theta;) - cos(-&theta;) - isin(-&theta;)]/2i = <b>sin(&theta;)</b>
</p>
</blockquote>
<p>
The imaginary has simply cancelled out
</p>
<div class="org-src-container">
<pre class="src src-octave">n<span style="color: #483d8b;">=</span>9
samples<span style="color: #483d8b;">=</span>[0<span style="color: #483d8b;">:</span>(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n)<span style="color: #483d8b;">:</span>(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">-</span>(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n))]
round(cos(samples)<span style="color: #483d8b;">.*</span>100)<span style="color: #483d8b;">./</span>100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0.77 | 0.17 | -0.5 | -0.94 | -0.94 | -0.5 | 0.17 | 0.77 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">round((exp(i<span style="color: #483d8b;">*</span>samples)<span style="color: #483d8b;">+</span>exp(<span style="color: #483d8b;">-</span>i<span style="color: #483d8b;">*</span>samples))<span style="color: #483d8b;">./</span>2<span style="color: #483d8b;">.*</span>100)<span style="color: #483d8b;">./</span>100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0.77 | 0.17 | -0.5 | -0.94 | -0.94 | -0.5 | 0.17 | 0.77 |</span>
</pre>
</div>

<p>
If we subsitute <b>&theta;</b> with <b>-2&pi;&phi;/n</b> then we can write sine and cosine in terms of our previous Fourier series terms:
</p>
<blockquote>
<p>
cos(2&pi;&phi;/n) = [&xi;<sup>k</sup> + &xi;<sup>-&phi;</sup>]/2 <br>
sin(2&pi;&phi;/n) = [&xi;<sup>k</sup> - &xi;<sup>-&phi;</sup>]/2i
</p>
</blockquote>
<blockquote>
<p>
<b>Note</b>: b/c these are cyclical functions:
</p>
<ul class="org-ul">
<li>sin(-&theta;) = sin(2&pi; - &theta;)</li>
<li>cos(-&theta;) = cos(2&pi; - &theta;)</li>
<li>e<sup>-i&theta;</sup> = e<sup>i(2&pi;-&theta;)</sup></li>
<li>&xi;<sup>-&phi;</sup> = &xi;<sup>n-&phi;</sup></li>
</ul>
</blockquote>
<p>
With some rearranging we can rewrite these as:
</p>
<blockquote>
<p>
cos(2&pi;&phi;) = n*[&xi;<sup>n-&phi;</sup> + &xi;<sup>&phi;</sup>]/2 <br>
sin(2&pi;&phi;) = n*[&xi;<sup>n-&phi;</sup> - &xi;<sup>&phi;</sup>]/2i
</p>
</blockquote>

<p>
Each one of these is just the sum of two columns in our fourier matrix.
So that:
</p>
<ul class="org-ul">
<li>cos(2&pi; * 2) = (1/n)F<sup>*</sup>x<sup>T</sup></li>
</ul>

<p>
For instance if <b>&phi;</b> = 2 we would pick <b>x</b> to be
</p>
<ul class="org-ul">
<li>x = [ 0 0 n/2 0 0 .. 0 0 n/2 0 0]<sub>1,n</sub></li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">quickRound(
    real((fourierMatrix(n)<span style="color: #483d8b;">'*</span>[0 0 n<span style="color: #483d8b;">/</span>2 0 0 0 0 n<span style="color: #483d8b;">/</span>2 0]<span style="color: #483d8b;">.'</span>)<span style="color: #483d8b;">./</span>n)<span style="color: #483d8b;">.'</span>)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0.174 | -0.94 | -0.5 | 0.766 | 0.766 | -0.5 | -0.94 | 0.174 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">quickRound(
  cos(2<span style="color: #483d8b;">*</span>samples))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0.174 | -0.94 | -0.5 | 0.766 | 0.766 | -0.5 | -0.94 | 0.174 |</span>
</pre>
</div>

<p>
Similarly with the sine function, except with an extra minus sign:
</p>
<ul class="org-ul">
<li>y = [ 0 0 -n/2i 0 0 .. 0 0 n/2i 0]<sub>1,n</sub></li>
</ul>
<p>
So that:
</p>
<ul class="org-ul">
<li>sin(2&pi; * 2) = (1/n)F<sup>*</sup>y<sup>T</sup></li>
</ul>
<blockquote>
<p>
<b>Note</b>: The indeces are a shifted b/c the first Fourier vector is for <b>&phi;=0</b> and the last is for <b>&phi;=n-1</b>
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">quickRound(
  (real(fourierMatrix(n)<span style="color: #483d8b;">'*</span>[0 0 <span style="color: #483d8b;">-</span>n<span style="color: #483d8b;">/</span>2i 0 0 0 0 n<span style="color: #483d8b;">/</span>2i 0]<span style="color: #483d8b;">.'./</span>n)<span style="color: #483d8b;">'</span>))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0 | 0.985 | 0.342 | -0.866 | -0.643 | 0.643 | 0.866 | -0.342 | -0.985 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">quickRound(
  sin(2<span style="color: #483d8b;">*</span>samples))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0 | 0.985 | 0.342 | -0.866 | -0.643 | 0.643 | 0.866 | -0.342 | -0.985 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">quickRound(
    fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(2<span style="color: #483d8b;">*</span>samples)<span style="color: #483d8b;">'</span>)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0+0i    |</span>
<span style="color: #0000ff;">| 0+0i    |</span>
<span style="color: #0000ff;">| 0-4.5i  |</span>
<span style="color: #0000ff;">| -0+0i   |</span>
<span style="color: #0000ff;">| -0+0i   |</span>
<span style="color: #0000ff;">| -0+0i   |</span>
<span style="color: #0000ff;">| -0+0i   |</span>
<span style="color: #0000ff;">| -0+4.5i |</span>
<span style="color: #0000ff;">| 0-0i    |</span>
</pre>
</div>
<p>
For larger values it becomes difficult to look at the numbers - but a plot can make the effect aparant
</p>
<div class="org-src-container">
<pre class="src src-octave">phi <span style="color: #483d8b;">=</span> 2<span style="color: #483d8b;">;</span>
n <span style="color: #483d8b;">=</span> 50<span style="color: #483d8b;">;</span>
freqCoord <span style="color: #483d8b;">=</span> zeros(1<span style="color: #483d8b;">,</span>n)<span style="color: #483d8b;">;</span>
freqCoord(phi<span style="color: #483d8b;">-</span>1) <span style="color: #483d8b;">=</span> n<span style="color: #483d8b;">/</span>2<span style="color: #483d8b;">;</span> <span style="color: #b22222;">% Some offset issue..</span>
freqCoord(n<span style="color: #483d8b;">-</span>phi<span style="color: #483d8b;">-</span>1) <span style="color: #483d8b;">=</span> n<span style="color: #483d8b;">/</span>2<span style="color: #483d8b;">;</span>
scatter([1<span style="color: #483d8b;">:</span>n]<span style="color: #483d8b;">,</span>freqCoord)
hold on<span style="color: #483d8b;">;</span>
axis <span style="color: #8b2252;">"off"</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"freqCoord.svg"</span>
hold off<span style="color: #483d8b;">;</span>
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="./freqCoord.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<div class="org-src-container">
<pre class="src src-octave">scatter([1<span style="color: #483d8b;">:</span>n]<span style="color: #483d8b;">,</span> (real(fourierMatrix(n)<span style="color: #483d8b;">'*</span>freqCoord<span style="color: #483d8b;">'</span>)))
hold on<span style="color: #483d8b;">;</span>
axis <span style="color: #8b2252;">"off"</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"afterFourierMatrix.svg"</span>
hold off<span style="color: #483d8b;">;</span>
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="./afterFourierMatrix.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-org87f249d" class="outline-3">
<h3 id="org87f249d">How does a phase shift look in this basis?</h3>
<div class="outline-text-3" id="text-org87f249d">
<p>
Notice how the cosines have real coordinates and the sines have imaginary coordinates. Combining the two, each complex coordinate in the fourier basis generates one of each and the result is purely real
</p>
<ul class="org-ul">
<li>v = &real;(v) + &image;(v)  &#x2026;.  (technically this is not a coordinate b/c it will have a mirror at n-k)</li>
<li>F<sup>*</sup>v/n = F<sup>*</sup>&real;(v)/n + F<sup>*</sup>&image;(v)/n = &alpha; sin(&#x2026;) + &beta; cos(&#x2026;)</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">n <span style="color: #483d8b;">=</span> 9
v <span style="color: #483d8b;">=</span> [0 0 n<span style="color: #483d8b;">/</span>2 0 0 0 0 n<span style="color: #483d8b;">/</span>2 0] .<span style="color: #483d8b;">+</span> [0 0 <span style="color: #483d8b;">-</span>n<span style="color: #483d8b;">/</span>2i 0 0 0 0 n<span style="color: #483d8b;">/</span>2i 0]
</pre>
</div>
<div class="org-src-container">
<pre class="src src-octave">quickRound(
  (real(fourierMatrix(n)<span style="color: #483d8b;">'*</span>v<span style="color: #483d8b;">.'</span>)<span style="color: #483d8b;">./</span>n)<span style="color: #483d8b;">.'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 1.158 | -0.598 | -1.366 | 0.123 | 1.409 | 0.366 | -1.282 | -0.811 |</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-octave">quickRound(
  cos(2<span style="color: #483d8b;">*</span>samples).<span style="color: #483d8b;">+</span>sin(2<span style="color: #483d8b;">*</span>samples))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 1.158 | -0.598 | -1.366 | 0.123 | 1.409 | 0.366 | -1.282 | -0.811 |</span>
</pre>
</div>
<p>
Sinusoidals have an amazing property that if you add sinusoidals of the same frequency (but different amplitudes and/or phases) you always get back just one sinusoidal of that frequency.
</p>

<p>
In our case we are simply adding the <i>sine</i> and <i>cosine</i> and the additive property comes out of the trig identity:
</p>
<ul class="org-ul">
<li>sin(A+B) = sin(A)cos(B)+cos(A)sin(B)</li>
</ul>
<p>
So given any <i>sine</i> wave with a phase shift we can decompose it into the sum of a <i>sine</i> and <i>cosine</i>
</p>
<ul class="org-ul">
<li>Asin(&omega; t + &phi;)</li>
<li>= Asin(&phi;)cos(&omega;t)+Acos(&phi;)sin(&omega; t)</li>
<li>= A<sub>1</sub>cos(&omega; t) + A<sub>2</sub>sin(&omega; t)  <i>.. bc &phi; is a constant</i></li>
</ul>
<p>
Working back we get the general rules for <b>harmonic addition</b>
</p>
<ul class="org-ul">
<li>&alpha; sin(&omega;t) + &beta; cos(&omega;t) = &gamma; sin(&omega;t+&theta;)</li>
<li>&gamma; = &radic;[&alpha;<sup>2</sup>+&beta;<sup>2</sup>]</li>
<li>&theta; = atan(&beta;/&alpha;)</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">gamma <span style="color: #483d8b;">=</span> sqrt(1<span style="color: #483d8b;">^</span>2<span style="color: #483d8b;">+</span>1<span style="color: #483d8b;">^</span>2) 
theta <span style="color: #483d8b;">=</span> atan(1)
quickRound(
gamma<span style="color: #483d8b;">*</span>sin(2<span style="color: #483d8b;">*</span>samples<span style="color: #483d8b;">+</span>theta))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 1.158 | -0.598 | -1.366 | 0.123 | 1.409 | 0.366 | -1.282 | -0.811 |</span>
</pre>
</div>

<p>
So when the complex coordinate gives us a sine and cosine of the same frequency what it's really giving us is a phase shifted sine wave. However the harmonic addition formula gives us a few crucial extra guarantees. Even if the input phase shifts (say there is a delayed in recording the input signal), while that would lead to a change in the real and imaginary coordinate components, the norm/length will remain constant b/c <i>&radic;[&alpha;<sup>2</sup>+&beta;<sup>2</sup>]</i> will always be equal to true sine wave's amplitude &gamma;.
</p>

<p>
Numerically for a generic input signal <b>x</b> if we take the norm<sup>2</sup> of each coordinate we will know the amplitude at each frequency component (at the expense of loosing all phase information) and we can then draw a spectrogram
</p>

<div class="org-src-container">
<pre class="src src-octave">v1 <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(2<span style="color: #483d8b;">*</span>samples <span style="color: #483d8b;">+</span> 5.432)<span style="color: #483d8b;">'</span>
quickRound( abs(v1)<span style="color: #483d8b;">'</span>)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0 | 0 | 4.5 | 0 | 0 | 0 | 0 | 4.5 | 0 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">v2 <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(2<span style="color: #483d8b;">*</span>samples <span style="color: #483d8b;">+</span> 2.345)<span style="color: #483d8b;">'</span>
quickRound( abs(v2)<span style="color: #483d8b;">'</span>)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0 | 0 | 4.5 | 0 | 0 | 0 | 0 | 4.5 | 0 |</span>
</pre>
</div>


<p>
And we can also determine the input's phase shift (though this is typically less useful)
</p>
<div class="org-src-container">
<pre class="src src-octave">v3 <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(2<span style="color: #483d8b;">*</span>samples <span style="color: #483d8b;">+</span> pi)<span style="color: #483d8b;">'</span>
quickRound(
    atan(imag(v3)<span style="color: #483d8b;">./</span>real(v3)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">|      0 |</span>
<span style="color: #0000ff;">|  0.067 |</span>
<span style="color: #0000ff;">|  1.571 |</span>
<span style="color: #0000ff;">|  0.369 |</span>
<span style="color: #0000ff;">| -0.965 |</span>
<span style="color: #0000ff;">|  0.322 |</span>
<span style="color: #0000ff;">| -1.125 |</span>
<span style="color: #0000ff;">| -1.571 |</span>
<span style="color: #0000ff;">| -0.632 |</span>
</pre>
</div>
<p>
B/c of numerical/computational error you end up with phase shifts for all values - even ones where no signal is present
</p>

<p>
This all illustrates a clear advantage of the Euler complex sinusoidals over real sine/cosine waves. While the magnitude of an equation like A*cos(2&pi;&phi;) changes with <i>&phi;</i>, its corresponding Euler basis vector <i>A&xi;<sup>&phi;</sup></i> will have constant magnitude <i>A</i> for all <i>&phi;</i> (and we just ignore the symmetric mirrored basis vectors that were making the original fluctuate)
</p>

<blockquote>
<p>
<b>Note</b>: While any actual coordinate in the Fourier basis can be broken up into a <i>real</i> and <i>imaginary</i> parts like we did, we can also write it out (like any complex number) in the form <i>Ae<sup>i&theta;</sup></i>. The complex constant/coordinate written in this form is known as the <b>phasor</b>. When multiplied times the basis vector <i>e^[i\omegat}</i> we see that the phasor fully specifies the phase and amplitude of the resulting sine wave in the real/time domain. Operations in the Fourier basis are in effect operations on these phasors.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org9fa562b" class="outline-3">
<h3 id="org9fa562b">Which frequencies are observable?</h3>
<div class="outline-text-3" id="text-org9fa562b">
<p>
When constructing our <i>sine</i> and <i>cosine</i> we noted in passing that <i>&xi;<sup>-&phi;</sup>{} = &xi;<sup>n-&phi;</sup></i> and we notice how each sigular frequency takes up two spots in the coordinate vector - one at <i>&phi;</i> and one at <i>n-&phi;</i>. This is an artifact of our sampling. Regular samples at one frequency will look identical to samples at other frequencies. The problems (and potential advantages) of frequency replication and aliasing <a href="./aliasing.html">are discussed separately</a>
</p>

<p>
In practical terms this means that you can't distinguish <i>&phi;</i> and <i>n-&phi;</i> frequencies, so if you want to use the Fourier basis to look at the spectrum on an input signal you need to ensure <i>n</i> is large enough that all the input frequencies lie between 0 and <i>n/2</i>. Then in the final Fourier basis you can entirely disregard basis vectors from <i>n/2</i> to <i>n</i> b/c they will mirror the <i>0</i> to <i>n/2</i> range.
</p>
<blockquote>
<p>
<b>Note</b> This doesn't represent a loss of information. The input had <b>n</b> real values the output has <b>n/2</b> complex coordinates (each made of 2 values).<br>
<b>Note</b> If the input is complex then this symmertry won't hold. But in most applications a complex input is not meaningful
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org3e9d4a6" class="outline-3">
<h3 id="org3e9d4a6">How does a frequency who's period isn't a whole fraction of the sample rate come out in this basis?</h3>
<div class="outline-text-3" id="text-org3e9d4a6">
<p>
All the previous math had assumed for simplicity that the input was at a frequency that matches one of the basis vectors - that it in effect produced one coordinate point. But how about if <i>&phi;</i> is not equal to a <i>k</i> value?
</p>

<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(4.321<span style="color: #483d8b;">*</span>samples <span style="color: #483d8b;">+</span> 2.345)<span style="color: #483d8b;">'</span>
quickRound( abs(v)<span style="color: #483d8b;">'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0.816 | 0.869 | 1.068 | 1.652 | 5.402 | 5.402 | 1.652 | 1.068 | 0.869 |</span>
</pre>
</div>


<ul class="org-ul">
<li>[1 - e<sup>i(w<sub>x</sub>-w<sub>k</sub>)NT</sup>] / [1 - e<sup>i(w<sub>x</sub>-w<sub>k</sub>)T</sup>]</li>
<li>[1 - cos((w<sub>x</sub>-w<sub>k</sub>)NT) + i sin((w<sub>x</sub>-w<sub>k</sub>)NT) ] / [1 - cos((w<sub>x</sub>-w<sub>k</sub>)T) + i sin((w<sub>x</sub>-w<sub>k</sub>)T) ]</li>
</ul>


<ul class="org-ul">
<li>sin(θ) = [eiθ - e-iθ]/2i</li>
<li>sin((x-k)NT/2) = [e<sup>i(x-k)NT/2</sup>- e<sup>-i(x-k)NT/2)</sup>]/2i</li>
<li>sin((x-k)T/2) = [e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]/2i</li>
<li>sin((x-k)NT/2)/sin((x-k)T/2)
<ul class="org-ul">
<li>= [e<sup>i(x-k)NT/2</sup>- e<sup>-i(x-k)NT/2)</sup>]/[e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]</li>
</ul></li>
<li>e<sup>i(x-k)(N-1)T/2</sup> * sin((x-k)NT/2)/sin((x-k)T/2)
<ul class="org-ul">
<li>= e<sup>i(x-k)(N-1)T/2</sup> * [e<sup>i(x-k)NT/2</sup>- e<sup>-i(x-k)NT/2)</sup>]/[e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]</li>
<li>= [e<sup>i(x-k)NT/2+i(x-k)(N-1)T/2</sup>- e<sup>-i(x-k)NT/2)+i(x-k)(N-1)T/2</sup>]/[e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]</li>
<li>= [e<sup>i(x-k)T/2*(N+(N-1))</sup>- e<sup>-i(x-k)T/2*(N+(N-1))</sup>]/[e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]</li>
</ul></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org6e911dd" class="outline-2">
<h2 id="org6e911dd">Amplitude Modulation</h2>
<div class="outline-text-2" id="text-org6e911dd">
<p>
This is a common occurance. You have a carrier wave that is modulated by a signal
</p>

<p>
The slower signal is called the <i>carrier wave</i>
</p>
<blockquote>
<p>
[1+ &alpha; &middot; a<sub>m</sub>(t)] &middot; A<sub>c</sub>sin(&omega;<sub>c</sub>t+&phi;<sub>c</sub>)
</p>
</blockquote>
<dl class="org-dl">
<dt>A<sub>c</sub>sin(&omega;t+&phi;<sub>c</sub>)</dt><dd>is the carrier wave</dd>
<dt>&alpha;</dt><dd>the modulation index [0,1]</dd>
<dt>a<sub>m</sub></dt><dd>is the signal</dd>
<dt>&omega;<sub>c</sub></dt><dd>is the center frequency</dd>
</dl>
<p>
The end result is a sum of the carrier and the product of the carrier with the signal <b>a<sub>m</sub></b>
</p>
<blockquote>
<p>
A<sub>c</sub>sin(&omega;<sub>c</sub>t+&phi;<sub>c</sub>) + &alpha; a<sub>m</sub>(t) A<sub>c</sub>sin(&omega;<sub>c</sub>t+&phi;<sub>c</sub>)
</p>
</blockquote>
</div>

<div id="outline-container-orgbfcd896" class="outline-3">
<h3 id="orgbfcd896">Sinusoidal AM</h3>
<div class="outline-text-3" id="text-orgbfcd896">
<p>
If <b>a<sub>m</sub></b> is a sinusoid then
</p>
<blockquote>
<p>
A<sub>c</sub>sin(&omega;<sub>c</sub>t+&phi;<sub>c</sub>) + &alpha; sin(&omega;<sub>m</sub>t+&phi;<sub>m</sub>) A<sub>c</sub>sin(&omega;t+&phi;<sub>c</sub>)
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">n <span style="color: #483d8b;">=</span> 200
x <span style="color: #483d8b;">=</span> [0<span style="color: #483d8b;">:</span>2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n<span style="color: #483d8b;">:</span>(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">-</span>2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n)]<span style="color: #483d8b;">;</span> <span style="color: #b22222;">% Maybe there is less stupid way to do this</span>
wc <span style="color: #483d8b;">=</span> 10<span style="color: #483d8b;">;</span>
wm <span style="color: #483d8b;">=</span> 2<span style="color: #483d8b;">;</span>
a <span style="color: #483d8b;">=</span> 0.5<span style="color: #483d8b;">;</span>
y <span style="color: #483d8b;">=</span> sin(wc <span style="color: #483d8b;">.*</span> x) <span style="color: #483d8b;">+</span> a <span style="color: #483d8b;">*</span> sin(wm<span style="color: #483d8b;">.*</span>x) <span style="color: #483d8b;">.*</span> sin(wc<span style="color: #483d8b;">.*</span>x)<span style="color: #483d8b;">;</span>
scatter(x<span style="color: #483d8b;">,</span>y)<span style="color: #483d8b;">;</span>
hold on<span style="color: #483d8b;">;</span>
axis <span style="color: #8b2252;">"off"</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"am-product.svg"</span>
hold off<span style="color: #483d8b;">;</span>
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="./am-product.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
However this product is inconvenient b/c it's not immediately clear how a product of sinusoids looks in the frequency domain. So here we use the trigonometric identity
</p>
<blockquote>
<p>
sin(A) sin(B) = [ cos(A-B) - cos(A+B) ] / 2
</p>
</blockquote>

<p>
And the end result is a sum of three sinusoids - the latter two have a frequency slight shifted off the carrier frequency 
</p>

<blockquote>
<p>
A<sub>c</sub>sin(&omega;<sub>c</sub>t+&phi;<sub>c</sub>) + &alpha; cos[(&omega;<sub>c</sub> - &omega;<sub>m</sub>)t]/2 - &alpha; cos[(&omega;<sub>c</sub> + &omega;<sub>m</sub>)t]/2
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">y <span style="color: #483d8b;">=</span> sin(wc<span style="color: #483d8b;">.*</span>x) <span style="color: #483d8b;">+</span> a <span style="color: #483d8b;">*</span> cos((wc<span style="color: #483d8b;">-</span>wm)<span style="color: #483d8b;">.*</span>x)<span style="color: #483d8b;">./</span>2 <span style="color: #483d8b;">-</span> a <span style="color: #483d8b;">*</span> cos((wc<span style="color: #483d8b;">+</span>wm)<span style="color: #483d8b;">.*</span>x)<span style="color: #483d8b;">./</span>2
scatter(x<span style="color: #483d8b;">,</span> y)
hold on<span style="color: #483d8b;">;</span>
axis <span style="color: #8b2252;">"off"</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"am-decomposed.svg"</span>
hold off<span style="color: #483d8b;">;</span>
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="./am-decomposed.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<div class="org-src-container">
<pre class="src src-octave">scatter(x<span style="color: #483d8b;">,</span>abs(fourierMatrix(n)<span style="color: #483d8b;">'*</span>y<span style="color: #483d8b;">'</span>))<span style="color: #483d8b;">;</span>
hold on<span style="color: #483d8b;">;</span>
axis <span style="color: #8b2252;">"off"</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"am-freq.svg"</span>
hold off<span style="color: #483d8b;">;</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="./am-freq.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org5ad822b" class="outline-2">
<h2 id="org5ad822b">Frequency modulation</h2>
<div class="outline-text-2" id="text-org5ad822b">
<p>
Not as omnipresent is frequency modulation
</p>

<blockquote>
<p>
A<sub>c</sub>cos(&omega;<sub>c</sub>t + &phi;<sub>c</sub> + A<sub>m</sub> sin(&omega;<sub>m</sub>t + &phi;<sub>m</sub>))
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">y <span style="color: #483d8b;">=</span> a <span style="color: #483d8b;">.*</span> cos(wc<span style="color: #483d8b;">.*</span>x .<span style="color: #483d8b;">+</span> 2 <span style="color: #483d8b;">.*</span> cos(wm<span style="color: #483d8b;">.*</span>x))
scatter(x<span style="color: #483d8b;">,</span> y)
hold on<span style="color: #483d8b;">;</span>
axis <span style="color: #8b2252;">"off"</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"fm-direct.svg"</span>
hold off<span style="color: #483d8b;">;</span>
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="./fm-direct.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
However this results in a more complicated frequency spread invlovling Bessle functions. Here is how it looks.. but an explanation not provided b/c I don't understand it.. see: <a href="https://ccrma.stanford.edu/~jos/mdft/Bessel_Functions.html">https://ccrma.stanford.edu/~jos/mdft/Bessel_Functions.html</a>
</p>

<div class="org-src-container">
<pre class="src src-octave">scatter(x<span style="color: #483d8b;">,</span>abs(fourierMatrix(n)<span style="color: #483d8b;">'*</span>y<span style="color: #483d8b;">'</span>))<span style="color: #483d8b;">;</span>
hold on<span style="color: #483d8b;">;</span>
axis <span style="color: #8b2252;">"off"</span>
print <span style="color: #8b2252;">"-S720,160"</span> <span style="color: #8b2252;">"fm-freq.svg"</span>
hold off<span style="color: #483d8b;">;</span>
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="./fm-freq.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>
<div id="outline-container-org4f5159f" class="outline-2">
<h2 id="org4f5159f">Addendum</h2>
<div class="outline-text-2" id="text-org4f5159f">
</div>
<div id="outline-container-orgf72c9bb" class="outline-3">
<h3 id="orgf72c9bb">LTI Systems</h3>
<div class="outline-text-3" id="text-orgf72c9bb">
<p>
Linear time invariant systems
</p>
<ul class="org-ul">
<li>characterizes all filters</li>
<li>sinusoids going through a LTI give you back the same sinusoid but with the amplitude or phase modified</li>
<li>LTI systems can be written as a Topletz matrix</li>
<li>If it's causal then the Topletz matrix is lower triangular</li>
</ul>
</div>
</div>
</div>
</div>
</body>
</html>
