<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Discrete Fourier Transform</title>
<meta name="generator" content="Org mode">
<meta name="author" content="George Kontsevich">
<meta name="description" content="DFT in MATLAB/Octave"
>
<link rel="stylesheet" type="text/css" href="../web/worg.css" />
<link rel="shortcut icon" href="../web/panda.svg" type="image/x-icon">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="../MathJax/MathJax.js?config=TeX-AMS_CHTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Discrete Fourier Transform</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf045120">Goal</a></li>
<li><a href="#org0201963">Complex numbers</a>
<ul>
<li><a href="#orgf785ed6">The complex plane</a></li>
</ul>
</li>
<li><a href="#orgcd70fd8">Complex number lengths</a>
<ul>
<li><a href="#orgd941e89">The Complex Conjugate</a></li>
<li><a href="#org932ffdb">Hermitian Transpose</a></li>
</ul>
</li>
<li><a href="#org9239766">The Unit Circle</a></li>
<li><a href="#orga33d721">Euler's Formula</a></li>
<li><a href="#org842778c">The roots of unity</a></li>
<li><a href="#org8baa7a1">Fourier series</a></li>
<li><a href="#org340e522">Fourier Vectors</a></li>
<li><a href="#org3d6c22a">Fourier Matrix</a></li>
<li><a href="#orgf23c05e">Frequency Space?</a>
<ul>
<li><a href="#org0ad736f">How does a sinusoidal look in this basis?</a></li>
<li><a href="#org7626577">How does a phase shift look in this basis?</a></li>
<li><a href="#org75b6ca0">Which frequencies are observable?</a></li>
<li><a href="#org4496499">How does a frequency who's period isn't a whole fraction of the sample rate come out in this basis?</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf045120" class="outline-2">
<h2 id="orgf045120">Goal</h2>
<div class="outline-text-2" id="text-orgf045120">
<ul class="org-ul">
<li>The goal is to build a new orthonormal basis. Orthonormality means that points in this basis aren't stretched or scaled and it allows the basis to be easily invertible.</li>

<li>We leverage multiplicative properties of complex numbers to construct this basis. It will make periodic components of our input apparant and can allow us to reason about frequencies and phases of signal components.</li>

<li>The new basis allows us to carry out a class of operations that are numerically intensive in the standard basis but much quicker in the frequency-basis.</li>
</ul>
</div>
</div>

<div id="outline-container-org0201963" class="outline-2">
<h2 id="org0201963">Complex numbers</h2>
<div class="outline-text-2" id="text-org0201963">
<p>
Complex numbers are of the form 
</p>
<blockquote>
<p>
a+ib
</p>
</blockquote>
<p>
where <b>i= &radic;(-1)</b><br>
<b>a</b> = real part
<b>b</b> = imaginary part. 
</p>
</div>

<div id="outline-container-orgf785ed6" class="outline-3">
<h3 id="orgf785ed6">The complex plane</h3>
<div class="outline-text-3" id="text-orgf785ed6">
<p>
The pair <b>(a,b)</b> are often referred to as a point on the complex plane. 
</p>

<p>
To draw this <i>complex plane</i> we treat <b>a*/*real</b> as the <i>x</i> coordinate and <b>b*/*imaginary</b> as the <i>y</i> coordinate.
</p>

<ul class="org-ul">
<li>1. Like 2D coordinates, we can add/translate them</li>
</ul>
<blockquote>
<p>
(a+ib) + (c+id) = (a+c) + i(b+d)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">1<span style="color: #483d8b;">+</span>5i <span style="color: #483d8b;">+</span> 3<span style="color: #483d8b;">+</span>2j
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">4+7i
</pre>
</div>
<ul class="org-ul">
<li>2. And Scale them</li>
</ul>
<blockquote>
<p>
c &times; (a+ib) = ca +icb 
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">10 <span style="color: #483d8b;">*</span> (1<span style="color: #483d8b;">+</span>5i)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">10+50i
</pre>
</div>

<ul class="org-ul">
<li>3. However <b>!UNLIKE!</b> 2D [x,y] coordinates, complex numbers can be multiplied:</li>
</ul>
<blockquote>
<p>
(a+ib) &times; (c+id) = (ac-bd) + i(ad+bc)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">(1<span style="color: #483d8b;">+</span>2i) <span style="color: #483d8b;">*</span> (3<span style="color: #483d8b;">+</span>4j)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">-5+10i
</pre>
</div>

<p>
<b>Notice</b> that if we are given 2 coordinates <b>[x<sub>0</sub>,y<sub>0</sub>]</b> and <b>[x<sub>1</sub>,y<sub>1</sub>]</b> we never ask ourselves to multiple them because multiplication between two points is simply no a defined operation. Just like how you don't ever multiple two points on a map. 
</p>

<p>
However in the complex-number case this operation comes naturally and it generates a new complex number!
</p>

<blockquote>
<p>
Note: You can do a dot and cross product between two [x,y] coordinates but:
</p>
<ul class="org-ul">
<li>[x<sub>0</sub>,y<sub>0</sub>] &bull; [x<sub>1</sub>,y<sub>1</sub>] &rarr; <i>scalar</i></li>
<li>[x<sub>0</sub>,y<sub>0</sub>] &times; [x<sub>1</sub>,y<sub>1</sub>] &rarr; <i>requires an extra <code>z</code> dimension</i></li>
</ul>
</blockquote>

<p>
So it's important to stress that points in the complex plane have this extra "feature" so you can't stretch the 2D coordinate interpretation too far. While adding two complex numbers can be visualized by putting the two vectors end-to-end - there is no equivalent visualization for a product in the general case (as far as I can tell). You can try multiplying arbitrary vectors and see that the result seems to point in a new direction.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcd70fd8" class="outline-2">
<h2 id="orgcd70fd8">Complex number lengths</h2>
<div class="outline-text-2" id="text-orgcd70fd8">
<p>
Just like real number, points and vectors, complex numbers have a "length" or magnitude
</p>
<blockquote>
<p>
&vert;a+ib&vert; = &radic;(a<sup>2</sup>+b<sup>2</sup>}
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">abs(3<span style="color: #483d8b;">+</span>4i)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">5
</pre>
</div>

<p>
And just a real number (and later vectors) this norm is a real scalar value <br>
</p>

<p>
One easy way to avoid absolute values when getting the magnitude of a real value is to square the value <b>a<sup>2</sup>=|a|<sup>2</sup></b> 
</p>
</div>

<div id="outline-container-orgd941e89" class="outline-3">
<h3 id="orgd941e89">The Complex Conjugate</h3>
<div class="outline-text-3" id="text-orgd941e89">
<p>
Notice that in the complex case the square of the magnitude can be calculated directly with:
</p>
<blockquote>
<p>
a<sup>2</sup>+b<sup>2</sup> = (a+ib)(a-ib)
</p>
</blockquote>
<p>
The <b>a-ib</b> is known as the <b>complex conjugate</b> of <b>a+ib</b>
</p>
<div class="org-src-container">
<pre class="src src-octave">conj(3<span style="color: #483d8b;">+</span>4j)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">3-4i
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> 3<span style="color: #483d8b;">+</span>4i
v<span style="color: #483d8b;">*</span>conj(v)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">25
</pre>
</div>

<p>
What's convenient about this way of getting the square of the magnitude is that is keeps working for real values. Since a real value <b>a</b> can be written as the complex number <b>a+i0</b> we can write its complex conjugate as <b>a-i0</b> and see that its norm is
</p>
<blockquote>
<p>
a<sup>2</sup>+0<sup>2</sup> = (a+i0)(a-i0) = a<sup>2</sup>
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> 3
v<span style="color: #483d8b;">*</span>conj(v)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">9
</pre>
</div>
</div>
</div>
<div id="outline-container-org932ffdb" class="outline-3">
<h3 id="org932ffdb">Hermitian Transpose</h3>
<div class="outline-text-3" id="text-org932ffdb">
<p>
To get lengths of 2D,3D,etc. points we use the inner product. It's like Pythagoras' Theorem except you leave the end result squared..
</p>
<blockquote>
<p>
v &middot; v<sup>T</sup><br>
= [a b c d] &middot; [a b c d]<sup>T</sup><br>
= a<sup>2</sup> + b<sup>2</sup> + c<sup>2</sup> + d<sup>2</sup>
</p>
</blockquote>
<p>
If we try to carry out the same operation using complex values for the vector elements, even in the <b>1x1</b> case we'd get a weird value
</p>
<blockquote>
<p>
z*z<sup>T</sup>=z<sup>2</sup>=(a+ib)<sup>2</sup>=a<sup>2</sup>+i2ab-b<sup>2</sup>
</p>
</blockquote>
<p>
this is a non-real value and doesn't match our understanding of length. So using the transpose to do an inner product with complex values doesn't give you a magnitude as before. 
</p>

<p>
But using complex conjugates in the transpose (a Hermitian transpose)  "fixes" the inner product
</p>
<blockquote>
<p>
[a+ib c+id]<sup>*</sup> = [a-ib c-d]<sup>T</sup>
</p>

<p>
[a+ib c+id][a+ib c+id]<sup>*</sup> = [(a<sup>2</sup>+b<sup>2</sup>)   (c<sup>2</sup>+d<sup>2</sup>)]<sup>T</sup>
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> [3<span style="color: #483d8b;">+</span>4i 6<span style="color: #483d8b;">+</span>8i]
v<span style="color: #483d8b;">'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 3-4i |</span>
<span style="color: #0000ff;">| 6-8i |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">v<span style="color: #483d8b;">*</span>v<span style="color: #483d8b;">'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">125
</pre>
</div>

<p>
Since the final value is <i>always</i> scalar/real:
</p>
<blockquote>
<p>
ab<sup>*</sup> = (ab<sup>*</sup>)<sup>*</sup> = a<sup>*</sup>b
</p>
</blockquote>
<ul class="org-ul">
<li></li>
</ul>
<p>
This means that either <b>a</b> or <b>b</b> can be conjugated when you want to do an inner product of two complex values
</p>

<p>
And again, when the vector values are all <i>real</i> the Hermetian transpose will behave exactly like a "normal" transpose - so the Hermitian transpose makes the standard transpose redundant
</p>
</div>
</div>
</div>

<div id="outline-container-org9239766" class="outline-2">
<h2 id="org9239766">The Unit Circle</h2>
<div class="outline-text-2" id="text-org9239766">
<p>
Note the obvious statement that that when a number or vector is of length one then the square of its magnitude is also equal to <b>1</b>. All these special points of length <b>1</b> lie on what's called the <i>unit cirle</i>. 
</p>

<p>
If we start with two complex numbers <b>a+ib</b> and <b>c+id</b> on the unit circle we can write
</p>
<blockquote>
<p>
(a<sup>2</sup>+b<sup>2</sup>)<sup>&frac12;</sup> = 1<br>
a<sup>2</sup>+b<sup>2</sup> = 1<br>
(c<sup>2</sup>+d<sup>2</sup>)<sup>&frac12;</sup> = 1<br>
c<sup>2</sup>+d<sup>2</sup> = 1
</p>
</blockquote>
<p>
As we saw, their product is the point <b>(ac-bd) + i(ad+bc)</b>.<br>
When we calculate the length of the product it also turns out to be <b>1</b>:
</p>
<blockquote>
<p>
[ (ac-bd)<sup>2</sup> + (ad+bc)<sup>2</sup> ]<sup>&frac12;</sup><br>
[ a<sup>2</sup>c<sup>2</sup> - 2acbd + b<sup>2</sup>d<sup>2</sup> + a<sup>2</sup>d<sup>2</sup> + 2adbc + b<sup>2</sup>c<sup>2</sup> ]<sup>&frac12;</sup><br>
[ a<sup>2</sup>c<sup>2</sup> + b<sup>2</sup>b<sup>2</sup> + a<sup>2</sup>d<sup>d</sup> + b<sup>2</sup>c<sup>2</sup> ]<sup>&frac12;</sup><br>
[ c<sup>2</sup>(a<sup>2</sup> + b<sup>2</sup>) + d<sup>2</sup>(a<sup>2</sup> + b<sup>2</sup>) ]<sup>(&frac12;)</sup>
</p>
</blockquote>
<p>
(last step is subsituting the previous equalities in to see it's equal to <b>1</b>)
</p>

<p>
This tells us that while in the general case the complex product is hard to visualize, we know that at least the product of any two points on the unit circle gives us a new point on the unit circle. 
</p>
<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> sqrt(0.2)<span style="color: #483d8b;">+</span>sqrt(0.8)<span style="color: #483d8b;">*</span>i
w <span style="color: #483d8b;">=</span> sqrt(0.69)<span style="color: #483d8b;">+</span>sqrt(0.31)<span style="color: #483d8b;">*</span>i
abs(v<span style="color: #483d8b;">*</span>w)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">0.9999999999999999
</pre>
</div>

<p>
This is often described as a <i>rotation</i> of the point on the <i>unit circle</i>
</p>
</div>
</div>
<div id="outline-container-orga33d721" class="outline-2">
<h2 id="orga33d721">Euler's Formula</h2>
<div class="outline-text-2" id="text-orga33d721">
<p>
To make the multiplicative rotations more natural we would like to start describing the points in terms of polar coordinates. The general conversion to polar coordinates is straightforward:
</p>
<blockquote>
<p>
radius = r = (a<sup>2</sup>+b<sup>2</sup>)<sup>1/2</sup><br>
angle = &theta; = atan(b/a)
</p>
</blockquote>
<p>
Going back is also easy
</p>
<blockquote>
<p>
a = rcos(&theta;)<br>
b = rsin(&theta;)
</p>
</blockquote>
<p>
So any complex number <b>z=a+ib</b>, through substitution, can be rewritten into a mathematically equivalent form using <b>r</b> and <b>&theta;</b>:
</p>
<blockquote>
<p>
z = rcos(&theta;) + irsin(&theta;)
</p>
</blockquote>
<p>
However a more compact representation of this is given by <b>Euler's formula</b>:
</p>
<blockquote>
<p>
re<sup>i&theta;</sup>=rcos(&theta;)+irsin(&theta;)
</p>
</blockquote>
<p>
A complete proof of this identity is a bit long, but the steps are:
</p>
<ol class="org-ol">
<li>Show that the derivative of <b>e<sup>x</sup></b> is <b>e<sup>x</sup></b> (it's the only equation of the form <b>a<sup>x</sup></b> that have this "stable" property)</li>
<li>Using the chain rule we see that the <b>n<sup>th</sup></b> derivative of <b>e<sup>ix</sup></b> will be equal to <b>i<sup>n</sup>e<sup>ix</sup></b></li>
<li><b>i<sup>n</sup></b> is a cyclic function with half its terms imaginary and half real</li>
<li>We then describe <b>e<sup>i&theta;</sup></b> around <b>0</b> in terms of the <i>Taylor/Maclaurin Series</i></li>
<li>Half the terms of the Taylor/Maclaurin Series will be imaginary and half real.</li>
<li>The real terms will match the Maclaurin Series of a cosine function and the imaginary will match those of the sine function</li>
</ol>
<p>
While the proof isn't very satisfying since there is no real way to visualize an imaginary power
</p>

<p>
TODO: Add explanation of imaginary exponent&#x2026;
</p>
<div class="org-src-container">
<pre class="src src-octave">123<span style="color: #483d8b;">*</span>exp(i<span style="color: #483d8b;">*</span>0.321)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">116.7172063656597+38.80842354690544i
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">123<span style="color: #483d8b;">*</span>cos(0.321)<span style="color: #483d8b;">+</span>i<span style="color: #483d8b;">*</span>123<span style="color: #483d8b;">*</span>sin(0.321)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">116.7172063656597+38.80842354690544i
</pre>
</div>

<p>
Using the trigonometric properties (which are self evident if you think of the graph and even/odd functions)
</p>
<blockquote>
<p>
sin(-&theta;)=-sin(&theta;)<br>
cos(-&theta;)= cos(&theta;)
</p>
</blockquote>
<p>
We can rewrite the complex conjugate as
</p>
<blockquote>
<p>
a - ib<br>
r cos(&theta;) - <i>i</i> r sin(&theta;)<br>
r cos(-&theta;) + <i>i</i> r sin{-&theta;) = <b>re<sup>-&theta;</sup></b>
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-octave">123<span style="color: #483d8b;">*</span>exp(<span style="color: #483d8b;">-</span>i<span style="color: #483d8b;">*</span>0.321)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">116.7172063656597-38.80842354690544i
</pre>
</div>

<p>
As we just saw in the previous section, the radius in the products of points on the unit cirle is always equal to one. so a polar coordinate system will bring the problem down from 2 variables, <i>a</i> and <i>b</i>, to just one constant <i>radius</i> of size <i>1</i> and one variable <i>angle</i> &theta;. The points on the unit circle can all be written down as:
</p>
<ul class="org-ul">
<li>e<sup>i&theta;</sup></li>
</ul>
<p>
And we can say the magnitude of the product of two of these is always equal to <i>1</i>
</p>
<ul class="org-ul">
<li>|| e<sup><i>i</i>&theta;</sup> * e<sup><i>i</i>&omega;</sup> || = 1</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">abs(exp(i<span style="color: #483d8b;">*</span>0.345)<span style="color: #483d8b;">*</span>exp(i<span style="color: #483d8b;">*</span>1.789))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">1
</pre>
</div>
<p>
Now notice that if <i>&omega;=2&pi;-&theta;</i> that:
</p>
<ul class="org-ul">
<li>e<sup> <i>i</i> (&theta;+&omega;)</sup> = e<sup> <i>i</i> 2&pi;</sup> = cos(2&pi;) + <i>i</i> sin(2&pi;) = 1 + <i>i</i> 0 = 1</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">exp(i<span style="color: #483d8b;">*</span>2<span style="color: #483d8b;">*</span>pi)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">1-2.449293598294706e-16i
</pre>
</div>
</div>
</div>

<div id="outline-container-org842778c" class="outline-2">
<h2 id="org842778c">The roots of unity</h2>
<div class="outline-text-2" id="text-org842778c">
<p>
Furthermore if <i>&alpha;=2&pi;/n</i> then:
</p>
<ul class="org-ul">
<li>[e<sup>i&alpha;</sup>]<sup>n</sup> = e<sup>in&alpha;</sup> = e<sup>i2&pi;</sup> = 1</li>
</ul>
<p>
This tells us that taking the n<sup>th</sup> root of <i>1</i> has a complex numbers solution! (in addition to the trivial solution of <i>1</i>)
</p>
<ul class="org-ul">
<li>1<sup>1/n</sup> = e<sup>i2&pi;/n</sup></li>
</ul>
<p>
The typical notation here is to say 
</p>
<ul class="org-ul">
<li>&xi; = e<sup>-i2&pi;/n</sup> = cos(2&pi;/n)+isin(2&pi;/n)</li>
<li>&xi;<sup>n</sup>=1</li>
</ul>
<p>
This &xi; is called the <b>n<sup>th</sup> root of unity</b>
</p>
<div class="org-src-container">
<pre class="src src-octave"><span style="color: #a020f0;">function</span> res <span style="color: #483d8b;">=</span> <span style="color: #0000ff;">rootOfUnity</span>(n)
  res <span style="color: #483d8b;">=</span> exp(i<span style="color: #483d8b;">*</span>2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">./</span>n)
<span style="color: #a020f0;">end</span>
</pre>
</div>

<p>
By extension we can also see that:
</p>
<ul class="org-ul">
<li>&xi;<sup>n+j</sup> = &xi;<sup>n</sup>&xi;<sup>j</sup> = &xi;<sup>j</sup></li>
<li>&xi;<sup>nk</sup> = [&xi;<sup>n</sup>]<sup>k</sup> = [e<sup>-i2&pi;</sup>]<sup>k</sup> = 1<sup>k</sup> = 1</li>
</ul>

<div class="org-src-container">
<pre class="src src-octave">rootOfUnity(7)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">0.6234898018587336+0.7818314824680298i
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">n <span style="color: #483d8b;">=</span> 7<span style="color: #483d8b;">;</span>
rootOfUnity(n)<span style="color: #483d8b;">^</span>n
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">1-4.996003610813204e-16i
</pre>
</div>
</div>
</div>

<div id="outline-container-org8baa7a1" class="outline-2">
<h2 id="org8baa7a1">Fourier series</h2>
<div class="outline-text-2" id="text-org8baa7a1">
<p>
The Fourier series is a very special sum of the exponents of an n<sup>th</sup> root of unity <b>&xi;</b>
</p>
<ul class="org-ul">
<li>1 + &xi;<sup>k</sup> + &xi;<sup>2k</sup> + &#x2026; + &xi;<sup>(n-2)k</sup> + &xi;<sup>(n-1)k</sup></li>
</ul>
<div class="org-src-container">
<pre class="src src-octave"><span style="color: #a020f0;">function</span> res <span style="color: #483d8b;">=</span> <span style="color: #0000ff;">fourierSeries</span>(n<span style="color: #483d8b;">,</span>k)
  res <span style="color: #483d8b;">=</span> rootOfUnity(n)<span style="color: #483d8b;">.^</span>((0<span style="color: #483d8b;">:</span>(n<span style="color: #483d8b;">-</span>1))<span style="color: #483d8b;">*</span>k)<span style="color: #483d8b;">;</span>
<span style="color: #a020f0;">end</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-octave">ans<span style="color: #483d8b;">=</span>disp(
        fourierSeries(5<span style="color: #483d8b;">,</span>3)<span style="color: #483d8b;">.'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1.00000 + 0.00000i  |</span>
<span style="color: #0000ff;">| -0.80902 - 0.58779i |</span>
<span style="color: #0000ff;">| 0.30902 + 0.95106i  |</span>
<span style="color: #0000ff;">| 0.30902 - 0.95106i  |</span>
<span style="color: #0000ff;">| -0.80902 + 0.58779i |</span>
<span style="color: #0000ff;">|                     |</span>
</pre>
</div>
<p>
Here the <i>k</i> can be any integer value, but the sum will always maintain the property that if it's multiplied by <i>&xi;<sup>k</sup></i> we get the same sequence back. The last term goes to <i>&xi;<sup>nk</sup> = 1</i> and the remaining terms in effect shift places giving us:
</p>
<ul class="org-ul">
<li>&xi;<sup>k</sup> + &xi;<sup>2k</sup> + &xi;<sup>3k</sup> + &#x2026; + &xi;<sup>(n-1)k</sup> + 1</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">n<span style="color: #483d8b;">=</span>5<span style="color: #483d8b;">,</span>k<span style="color: #483d8b;">=</span>3
ans<span style="color: #483d8b;">=</span>disp(
        (fourierSeries(n<span style="color: #483d8b;">,</span>k)<span style="color: #483d8b;">.*</span>(rootOfUnity(n)<span style="color: #483d8b;">^</span>k))<span style="color: #483d8b;">.'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| -0.80902 - 0.58779i |</span>
<span style="color: #0000ff;">| 0.30902 + 0.95106i  |</span>
<span style="color: #0000ff;">| 0.30902 - 0.95106i  |</span>
<span style="color: #0000ff;">| -0.80902 + 0.58779i |</span>
<span style="color: #0000ff;">| 1.00000 - 0.00000i  |</span>
<span style="color: #0000ff;">|                     |</span>
</pre>
</div>

<p>
So we can write
</p>
<ul class="org-ul">
<li>&xi;<sup>k</sup> * <i>fourier-series</i> = <i>fourier-series</i></li>
</ul>
<p>
Therefore
</p>
<ul class="org-ul">
<li>&xi;<sup>k</sup> * <i>fourier-series</i> - <i>fourier-series</i> = 0</li>
<li><i>fourier-series</i> * (&xi;<sup>k</sup> - 1) = 0</li>
</ul>
<p>
And therefore.. 
</p>
<ul class="org-ul">
<li><i>fourier-series</i>  = 0</li>
</ul>
<p>
.. or to write it out again in full form - for all integer values of <i>k</i>
</p>
<ul class="org-ul">
<li>1+&xi;<sup>k</sup>+&xi;<sup>2k</sup>+&#x2026;+&xi;<sup>(n-2)k</sup>+&xi;<sup>(n-1)k</sup> = 0</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">n<span style="color: #483d8b;">=</span>7<span style="color: #483d8b;">,</span>k<span style="color: #483d8b;">=</span>1
sum(fourierSeries(n<span style="color: #483d8b;">,</span>k))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">-3.33066907387547e-16
</pre>
</div>
</div>
</div>


<div id="outline-container-org340e522" class="outline-2">
<h2 id="org340e522">Fourier Vectors</h2>
<div class="outline-text-2" id="text-org340e522">
<p>
It turns out that Fourier series, when places in a vector with different values of <i>k</i>, form mutually orthogonal vectors - here I choose <i>r</i> and <i>s</i> for <i>k</i> and carry out the Hermitian inner product:
</p>
<ul class="org-ul">
<li>[ 1 &xi;<sup>r</sup> &xi;<sup>2r</sup> &#x2026; &xi;<sup>(n-1)r</sup> ] [ 1 &xi;<sup>s</sup> &xi;<sup>2s</sup> &#x2026; &xi;<sup>(n-1)s</sup> ]<sup>*</sup></li>
<li>[ 1 &xi;<sup>r</sup> &xi;<sup>2r</sup> &#x2026; &xi;<sup>(n-1)r</sup> ] [ 1 &xi;<sup>-s</sup> &xi;<sup>-2s</sup> &#x2026; &xi;<sup>-(n-1)s</sup> ]<sup>T</sup></li>
<li>1*1 + &xi;<sup>r</sup>*&xi;<sup>-s</sup> + &xi;<sup>2r</sup>*&xi;<sup>-2s</sup> + &#x2026; + &xi;<sup>(n-2)r</sup>&xi;<sup>-(n-2)s</sup>} + &xi;<sup>(n-1)r</sup>&xi;<sup>-(n-1)s</sup></li>
<li>1 + &xi;<sup>r-s</sup> + &xi;<sup>2(r-s)</sup> + &#x2026; + &xi;<sup>(n-2)(r-s)</sup> + &xi;<sup>(n-1)(r-s)</sup></li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">r<span style="color: #483d8b;">=</span>7<span style="color: #483d8b;">,</span> s<span style="color: #483d8b;">=</span>13<span style="color: #483d8b;">,</span> n<span style="color: #483d8b;">=</span> 11
fourierSeries(n<span style="color: #483d8b;">,</span>r)<span style="color: #483d8b;">*</span>fourierSeries(n<span style="color: #483d8b;">,</span>s)<span style="color: #483d8b;">'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">-2.331468351712829e-15
</pre>
</div>

<p>
Now <i>r-s</i> is just another <i>k</i> value from our Fourier series and so the sum will go to <i>0</i> <b>except</b> when <i>r=s</i>:
</p>
<ul class="org-ul">
<li>[ 1 &xi;<sup>k</sup> &xi;<sup>2k</sup> &#x2026; &xi;<sup>(n-1)k</sup> ]  [ 1 &xi;<sup>k</sup> &xi;<sup>2k</sup> &#x2026; &xi;<sup>(n-1)k</sup> ]<sup>*</sup></li>
<li>1*1 + &xi;<sup>k</sup>&xi;<sup>-k</sup> + &xi;<sup>2k</sup>&xi;<sup>-2k</sup> + &#x2026; + &xi;<sup>(n-1)k</sup> &xi;<sup>-(n-1)k</sup></li>
<li>1*1 + &xi;<sup>0</sup> + &xi;<sup>0</sup> + &#x2026; + &xi;<sup>0</sup></li>
<li>1 + 1 + 1 + &#x2026; + 1 = n</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">r<span style="color: #483d8b;">=</span>7<span style="color: #483d8b;">,</span> s<span style="color: #483d8b;">=</span>7<span style="color: #483d8b;">,</span> n<span style="color: #483d8b;">=</span> 11
fourierSeries(n<span style="color: #483d8b;">,</span>r)<span style="color: #483d8b;">*</span>fourierSeries(n<span style="color: #483d8b;">,</span>s)<span style="color: #483d8b;">'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">11.00000000000002
</pre>
</div>

<p>
You could also just view the <i>r=s</i> case as the sum of the 2-norms of the roots of unity. There are <i>n</i> terms and each one is necessarily of length <i>1</i>. Either way, the answer will always be <i>n</i> no matter what <i>k</i> you choose
and therefore the 2-norm/length all all fourier vectors is <i>n<sup>1/2</sup></i>
</p>

<p>
It's important to note that if you drop all the complex terms none of this works! You can't construct mutually orthogonal vectors out of purely real sine/cosine waves
</p>
</div>
</div>

<div id="outline-container-org3d6c22a" class="outline-2">
<h2 id="org3d6c22a">Fourier Matrix</h2>
<div class="outline-text-2" id="text-org3d6c22a">
<p>
We've just shown that the fourier vectors are orthogonal as long as the <i>k</i>'s are different. The only caveat is that when <i>k=n</i> then the result is identical to <i>k=0</i> and when <i>k=n+1</i> it's identical to <i>k=1</i> .. etc. So there are actually only <i>n</i> distinct fourier vectors. The next step is self evident. We just choose take the <i>n</i> distinct vectors and slap them together into a fourier matrix <b>F</b> and end up withh an orthogonal basis:<br>
<b>F</b> =
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&xi;</td>
<td class="org-left">&xi;<sup>2</sup></td>
<td class="org-left">&xi;<sup>3</sup></td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&xi;<sup>2</sup></td>
<td class="org-left">&xi;<sup>4</sup></td>
<td class="org-left">&xi;<sup>6</sup></td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&xi;<sup>3</sup></td>
<td class="org-left">&xi;<sup>6</sup></td>
<td class="org-left">&xi;<sup>9</sup></td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&xi;<sup>n-1</sup></td>
<td class="org-left">&xi;<sup>n-2</sup></td>
<td class="org-left">&#x2026;</td>
<td class="org-left">..</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-octave"><span style="color: #a020f0;">function</span> F <span style="color: #483d8b;">=</span> <span style="color: #0000ff;">fourierMatrix</span>(n)
  F<span style="color: #483d8b;">=</span>zeros(n<span style="color: #483d8b;">,</span>0)
  <span style="color: #a020f0;">for</span> k <span style="color: #483d8b;">=</span> 0<span style="color: #483d8b;">:</span>(n<span style="color: #483d8b;">-</span>1)
    F<span style="color: #483d8b;">=</span>horzcat(F<span style="color: #483d8b;">,</span>fourierSeries(n<span style="color: #483d8b;">,</span>k)<span style="color: #483d8b;">.'</span>)<span style="color: #483d8b;">;</span>
  <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">F <span style="color: #483d8b;">=</span> fourierMatrix(7)<span style="color: #483d8b;">;</span>
round(F<span style="color: #483d8b;">.*</span>1000)<span style="color: #483d8b;">./</span>1000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1+0i | 1+0i          | 1+0i          | 1+0i          | 1+0i          | 1+0i          | 1+0i          |</span>
<span style="color: #0000ff;">| 1+0i | 0.623+0.782i  | -0.223+0.975i | -0.901+0.434i | -0.901-0.434i | -0.223-0.975i | 0.623-0.782i  |</span>
<span style="color: #0000ff;">| 1+0i | -0.223+0.975i | -0.901-0.434i | 0.623-0.782i  | 0.623+0.782i  | -0.901+0.434i | -0.223-0.975i |</span>
<span style="color: #0000ff;">| 1+0i | -0.901+0.434i | 0.623-0.782i  | -0.223+0.975i | -0.223-0.975i | 0.623+0.782i  | -0.901-0.434i |</span>
<span style="color: #0000ff;">| 1+0i | -0.901-0.434i | 0.623+0.782i  | -0.223-0.975i | -0.223+0.975i | 0.623-0.782i  | -0.901+0.434i |</span>
<span style="color: #0000ff;">| 1+0i | -0.223-0.975i | -0.901+0.434i | 0.623+0.782i  | 0.623-0.782i  | -0.901-0.434i | -0.223+0.975i |</span>
<span style="color: #0000ff;">| 1+0i | 0.623-0.782i  | -0.223-0.975i | -0.901-0.434i | -0.901+0.434i | -0.223+0.975i | 0.623+0.782i  |</span>
</pre>
</div>

<p>
Looking at the real components of the columns - there is one constant component (the first column) and then <i>n</i> samples of the <i>cosine</i> function over one oscillation for the second column, <i>n</i> samples over 2 periods for the 3rd column, <i>n</i> samples over 3 periods.. etc. <br>
&real;(<b>F</b>) =
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">cos(1*2&pi;/n)</td>
<td class="org-left">cos(2*2&pi;/n)</td>
<td class="org-left">cos(3*2&pi;/n\)</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">cos(2*2&pi;/n)</td>
<td class="org-left">cos(4*2&pi;/n)</td>
<td class="org-left">cos(6*2&pi;/n)</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">cos(3*2&pi;/n)</td>
<td class="org-left">cos(6*2&pi;/n)</td>
<td class="org-left">cos(9*2&pi;/n)</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">..</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">cos([n-1]*2&pi;/n)</td>
<td class="org-left">cos(2[n-1]2&pi;/n)</td>
<td class="org-left">cos(3[n-1]*2&pi;/n)</td>
<td class="org-left">..</td>
</tr>
</tbody>
</table>

<p>
If your input is over 1 second then this maps to a sampled cosine function of 1Hz, 2Hz, 3Hz, etc..<br>
</p>
<div class="org-src-container">
<pre class="src src-octave">realF <span style="color: #483d8b;">=</span> real(F)<span style="color: #483d8b;">;</span>
round(realF<span style="color: #483d8b;">.*</span>1000)<span style="color: #483d8b;">./</span>1000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 |      1 |      1 |      1 |      1 |      1 |      1 |</span>
<span style="color: #0000ff;">| 1 |  0.623 | -0.223 | -0.901 | -0.901 | -0.223 |  0.623 |</span>
<span style="color: #0000ff;">| 1 | -0.223 | -0.901 |  0.623 |  0.623 | -0.901 | -0.223 |</span>
<span style="color: #0000ff;">| 1 | -0.901 |  0.623 | -0.223 | -0.223 |  0.623 | -0.901 |</span>
<span style="color: #0000ff;">| 1 | -0.901 |  0.623 | -0.223 | -0.223 |  0.623 | -0.901 |</span>
<span style="color: #0000ff;">| 1 | -0.223 | -0.901 |  0.623 |  0.623 | -0.901 | -0.223 |</span>
<span style="color: #0000ff;">| 1 |  0.623 | -0.223 | -0.901 | -0.901 | -0.223 |  0.623 |</span>
</pre>
</div>

<p>
However you will notice that there is a symmetry around the middle axis and higher frequencies look identical to lower frequencies (and hence the real values don't form an orthogonal basis)
</p>
<ul class="org-ul">
<li><b>&xi;<sup>n-k</sup></b> = cos((n-k)(2&pi;/n)+isin((n-k)(2&pi;/n)=cos(2&pi;+2&pi;k/n)+isin(2&pi;+2&pi;k/n)</li>
</ul>
<p>
b/c <i>sin(2&pi;+x)=sin(x)</i> we simplify
</p>
<ul class="org-ul">
<li>= cos(2&pi;k/n)+isin(2&pi;k/n) = <b>&xi;<sup>k</sup></b></li>
</ul>
<p>
The complex numbers are similarly not orthogonal, just the <i>n-k<sup>th</sup></i> column is the negative of the <i>k<sup>th</sup></i> column
</p>

<p>
Since each series (irrespective of the <i>k</i> exponent) has length <i>n<sup>1/2</sup></i> (remember that the self-inner norms equal <i>n</i>), all the columns of <b>F</b> can be normalized in one go by dividing the matrix by <i>n<sup>1/2</sup></i>. The resulting matrix <b>(1/n<sup>1/2</sup>)F</b> is now even better b/c it's orthonormal/unitary. Therefore its inverse is just its Hermitian transpose.
</p>

<ul class="org-ul">
<li>[(1/n<sup>1/2</sup>)F]<sup>-1</sup> = [(1/n<sup>1/2</sup>)F]<sup>*</sup></li>
<li>F<sup>-1</sup> = (1/n)F<sup>*</sup></li>
</ul>
<p>
In <b>F<sup>-1</sup>F</b> the diagonal elements will be the column magnitudes, which have been normalized to <i>1</i>, and the off diagonal elements will be inner products of orthogonal vectors and therefore <i>0</i> - so the product will give us the identity matrix <b>I</b>
</p>

<div class="org-src-container">
<pre class="src src-octave">normalizedF <span style="color: #483d8b;">=</span> F<span style="color: #483d8b;">./</span>sqrt(n) <span style="color: #b22222;">%Normalize the Fourier matrix</span>
I <span style="color: #483d8b;">=</span> normalizedF<span style="color: #483d8b;">*</span>normalizedF<span style="color: #483d8b;">'</span>
real(round(I<span style="color: #483d8b;">.*</span>1000)<span style="color: #483d8b;">./</span>1000)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0.636 |     0 |     0 |     0 |     0 |     0 |     0 |</span>
<span style="color: #0000ff;">|     0 | 0.636 |     0 |     0 |     0 |     0 |     0 |</span>
<span style="color: #0000ff;">|     0 |     0 | 0.636 |     0 |     0 |     0 |     0 |</span>
<span style="color: #0000ff;">|     0 |     0 |     0 | 0.636 |     0 |     0 |     0 |</span>
<span style="color: #0000ff;">|     0 |     0 |     0 |     0 | 0.636 |     0 |     0 |</span>
<span style="color: #0000ff;">|     0 |     0 |     0 |     0 |     0 | 0.636 |     0 |</span>
<span style="color: #0000ff;">|     0 |     0 |     0 |     0 |     0 |     0 | 0.636 |</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf23c05e" class="outline-2">
<h2 id="orgf23c05e">Frequency Space?</h2>
<div class="outline-text-2" id="text-orgf23c05e">
<p>
We constructed a very convenient basis that's easily invertible and independent of the input and we can now easily move to the basis and back but it's not exactly what one would imagine as "frequency space" and a few things are unresolved
</p>
</div>

<div id="outline-container-org0ad736f" class="outline-3">
<h3 id="org0ad736f">How does a sinusoidal look in this basis?</h3>
<div class="outline-text-3" id="text-org0ad736f">
<p>
If we can carefully pair Euler functions we get back bare sine/cosine functions with no imaginary parts
</p>
<ul class="org-ul">
<li>[e<sup>i&theta;</sup> + e<sup>-i&theta;</sup>]/2 = [cos(&theta;) + isin(&theta;) + cos(-&theta;) + isin(-&theta;)]/2 = <b>cos(&theta;)</b></li>
<li>[e<sup>i&theta;</sup> - e<sup>-i&theta;</sup>]/2i = [cos(&theta;) + isin(&theta;) - cos(-&theta;) - isin(-&theta;)]/2i = <b>sin(&theta;)</b></li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">n<span style="color: #483d8b;">=</span>9
samples<span style="color: #483d8b;">=</span>[0<span style="color: #483d8b;">:</span>(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n)<span style="color: #483d8b;">:</span>(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">-</span>(2<span style="color: #483d8b;">*</span>pi<span style="color: #483d8b;">/</span>n))]
round(cos(samples)<span style="color: #483d8b;">.*</span>100)<span style="color: #483d8b;">./</span>100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0.77 | 0.17 | -0.5 | -0.94 | -0.94 | -0.5 | 0.17 | 0.77 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">round((exp(i<span style="color: #483d8b;">*</span>samples)<span style="color: #483d8b;">+</span>exp(<span style="color: #483d8b;">-</span>i<span style="color: #483d8b;">*</span>samples))<span style="color: #483d8b;">./</span>2<span style="color: #483d8b;">.*</span>100)<span style="color: #483d8b;">./</span>100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0.77 | 0.17 | -0.5 | -0.94 | -0.94 | -0.5 | 0.17 | 0.77 |</span>
</pre>
</div>

<p>
We can subsitute <i>&theta;</i> with <i>-2&pi;&phi;/n</i> to get our more familiar Fourier series form:
</p>
<ul class="org-ul">
<li>cos(2&pi;&phi;/n) = [&xi;<sup>k</sup> + &xi;<sup>-&phi;</sup>]/2</li>
<li>sin(2&pi;&phi;/n) = [&xi;<sup>k</sup> - &xi;<sup>-&phi;</sup>]/2i</li>
</ul>
<blockquote>
<p>
<b>Note</b>: b/c these are cyclical functions:
</p>
<ul class="org-ul">
<li>sin(-&theta;) = sin(2&pi; - &theta;)</li>
<li>cos(-&theta;) = cos(2&pi; - &theta;)</li>
<li>e<sup>-i&theta;</sup> = e<sup>i(2&pi;-&theta;)</sup></li>
<li>&xi;<sup>-&phi;</sup>{} = &xi;<sup>n-&phi;</sup></li>
</ul>
</blockquote>
<p>
With some rearranging we can rewrite these as:
</p>
<ul class="org-ul">
<li>cos(2&pi;&phi;) = n*[&xi;<sup>n-&phi;</sup> + &xi;<sup>&phi;</sup>]/2</li>
<li>sin(2&pi;&phi;) = n*[&xi;<sup>n-&phi;</sup> - &xi;<sup>&phi;</sup>]/2i</li>
</ul>

<p>
And these now will correspond to basis vectors in our fourier matrix.
</p>

<p>
For instance if <i>&phi;</i> = 2 we can pick an <i>x</i>
</p>
<ul class="org-ul">
<li>x = [ 0 0 n/2 0 0 .. 0 0 n/2 0 0]<sub>1,n</sub></li>
</ul>
<p>
So that:
</p>
<ul class="org-ul">
<li>cos(2&pi; * 2) = (1/n)F<sup>*</sup>x<sup>T</sup></li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">quickRound(
    real((fourierMatrix(n)<span style="color: #483d8b;">'*</span>[0 0 n<span style="color: #483d8b;">/</span>2 0 0 0 0 n<span style="color: #483d8b;">/</span>2 0]<span style="color: #483d8b;">.'</span>)<span style="color: #483d8b;">./</span>n)<span style="color: #483d8b;">.'</span>)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0.174 | -0.94 | -0.5 | 0.766 | 0.766 | -0.5 | -0.94 | 0.174 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">quickRound(
  cos(2<span style="color: #483d8b;">*</span>samples))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 0.174 | -0.94 | -0.5 | 0.766 | 0.766 | -0.5 | -0.94 | 0.174 |</span>
</pre>
</div>

<p>
Similarly with the sine function, except with an extra minus sign:
</p>
<ul class="org-ul">
<li>y = [ 0 0 -n/2i 0 0 .. 0 0 n/2i 0 0]<sub>1,n</sub></li>
</ul>
<p>
So that:
</p>
<ul class="org-ul">
<li>sin(2&pi; * 2) = (1/n)F<sup>*</sup>y<sup>T</sup></li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">quickRound(
  (real(fourierMatrix(n)<span style="color: #483d8b;">'*</span>[0 0 <span style="color: #483d8b;">-</span>n<span style="color: #483d8b;">/</span>2i 0 0 0 0 n<span style="color: #483d8b;">/</span>2i 0]<span style="color: #483d8b;">.'./</span>n)<span style="color: #483d8b;">'</span>))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0 | 0.985 | 0.342 | -0.866 | -0.643 | 0.643 | 0.866 | -0.342 | -0.985 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">quickRound(
  sin(2<span style="color: #483d8b;">*</span>samples))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0 | 0.985 | 0.342 | -0.866 | -0.643 | 0.643 | 0.866 | -0.342 | -0.985 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">quickRound(
    fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(2<span style="color: #483d8b;">*</span>samples)<span style="color: #483d8b;">'</span>)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0+0i    |</span>
<span style="color: #0000ff;">| 0+0i    |</span>
<span style="color: #0000ff;">| 0-4.5i  |</span>
<span style="color: #0000ff;">| -0+0i   |</span>
<span style="color: #0000ff;">| -0+0i   |</span>
<span style="color: #0000ff;">| -0+0i   |</span>
<span style="color: #0000ff;">| -0+0i   |</span>
<span style="color: #0000ff;">| -0+4.5i |</span>
<span style="color: #0000ff;">| 0-0i    |</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7626577" class="outline-3">
<h3 id="org7626577">How does a phase shift look in this basis?</h3>
<div class="outline-text-3" id="text-org7626577">
<p>
Notice how the cosines have real coordinates and the sines have imaginary coordinates. Combining the two, each complex coordinate in the fourier basis generates one of each and the result is purely real
</p>
<ul class="org-ul">
<li>v = &real;(v) + &image;(v)  &#x2026;.  (technically this is not a coordinate b/c it will have a mirror at n-k)</li>
<li>F<sup>*</sup>v/n = F<sup>*</sup>&real;(v)/n + F<sup>*</sup>&image;(v)/n = &alpha; sin(&#x2026;) + &beta; cos(&#x2026;)</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> [0 0 n<span style="color: #483d8b;">/</span>2 0 0 0 0 n<span style="color: #483d8b;">/</span>2 0] .<span style="color: #483d8b;">+</span> [0 0 <span style="color: #483d8b;">-</span>n<span style="color: #483d8b;">/</span>2i 0 0 0 0 n<span style="color: #483d8b;">/</span>2i 0]
</pre>
</div>
<div class="org-src-container">
<pre class="src src-octave">quickRound(
  (real(fourierMatrix(n)<span style="color: #483d8b;">'*</span>v<span style="color: #483d8b;">.'</span>)<span style="color: #483d8b;">./</span>n)<span style="color: #483d8b;">.'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 1.158 | -0.598 | -1.366 | 0.123 | 1.409 | 0.366 | -1.282 | -0.811 |</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-octave">quickRound(
  cos(2<span style="color: #483d8b;">*</span>samples).<span style="color: #483d8b;">+</span>sin(2<span style="color: #483d8b;">*</span>samples))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 1.158 | -0.598 | -1.366 | 0.123 | 1.409 | 0.366 | -1.282 | -0.811 |</span>
</pre>
</div>
<p>
Sinusoidals have an amazing property that if you add sinusoidals of the same frequency (but different amplitudes and/or phases) you always get back just one sinusoidal of that frequency.
</p>

<p>
In our case we are simply adding the <i>sine</i> and <i>cosine</i> and the additive property comes out of the trig identity:
</p>
<ul class="org-ul">
<li>sin(A+B) = sin(A)cos(B)+cos(A)sin(B)</li>
</ul>
<p>
So given any <i>sine</i> wave with a phase shift we can decompose it into the sum of a <i>sine</i> and <i>cosine</i>
</p>
<ul class="org-ul">
<li>Asin(&omega; t + &phi;)</li>
<li>= Asin(&phi;)cos(&omega;t)+Acos(&phi;)sin(&omega; t)</li>
<li>= A<sub>1</sub>cos(&omega; t) + A<sub>2</sub>sin(&omega; t)  <i>.. bc &phi; is a constant</i></li>
</ul>
<p>
Working back we get the general rules for <b>harmonic addition</b>
</p>
<ul class="org-ul">
<li>&alpha; sin(&omega;t) + &beta; cos(&omega;t) = &gamma; sin(&omega;t+&theta;)</li>
<li>&gamma; = &radic;[&alpha;<sup>2</sup>+&beta;<sup>2</sup>]</li>
<li>&theta; = atan(&beta;/&alpha;)</li>
</ul>
<div class="org-src-container">
<pre class="src src-octave">gamma <span style="color: #483d8b;">=</span> sqrt(1<span style="color: #483d8b;">^</span>2<span style="color: #483d8b;">+</span>1<span style="color: #483d8b;">^</span>2) 
theta <span style="color: #483d8b;">=</span> atan(1)
quickRound(
gamma<span style="color: #483d8b;">*</span>sin(2<span style="color: #483d8b;">*</span>samples<span style="color: #483d8b;">+</span>theta))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 1 | 1.158 | -0.598 | -1.366 | 0.123 | 1.409 | 0.366 | -1.282 | -0.811 |</span>
</pre>
</div>

<p>
So when the complex coordinate gives us a sine and cosine of the same frequency what it's really giving us is a phase shifted sine wave. However the harmonic addition formula gives us a few crucial extra guarantees. Even if the input phase shifts (say there is a delayed in recording the input signal), while that would lead to a change in the real and imaginary coordinate components, the norm/length will remain constant b/c <i>&radic;[&alpha;<sup>2</sup>+&beta;<sup>2</sup>]</i> will always be equal to true sine wave's amplitude &gamma;.
</p>

<p>
Numerically for a generic input signal <b>x</b> if we take the norm<sup>2</sup> of each coordinate we will know the amplitude at each frequency component (at the expense of loosing all phase information) and we can then draw a spectrogram
</p>

<div class="org-src-container">
<pre class="src src-octave">v1 <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(2<span style="color: #483d8b;">*</span>samples <span style="color: #483d8b;">+</span> 5.432)<span style="color: #483d8b;">'</span>
quickRound( abs(v1)<span style="color: #483d8b;">'</span>)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0 | 0 | 4.5 | 0 | 0 | 0 | 0 | 4.5 | 0 |</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-octave">v2 <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(2<span style="color: #483d8b;">*</span>samples <span style="color: #483d8b;">+</span> 2.345)<span style="color: #483d8b;">'</span>
quickRound( abs(v2)<span style="color: #483d8b;">'</span>)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0 | 0 | 4.5 | 0 | 0 | 0 | 0 | 4.5 | 0 |</span>
</pre>
</div>


<p>
And we can also determine the input's phase shift (though this is typically less useful)
</p>
<div class="org-src-container">
<pre class="src src-octave">v3 <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(2<span style="color: #483d8b;">*</span>samples <span style="color: #483d8b;">+</span> pi)<span style="color: #483d8b;">'</span>
quickRound(
    atan(imag(v3)<span style="color: #483d8b;">./</span>real(v3)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">|      0 |</span>
<span style="color: #0000ff;">|  0.067 |</span>
<span style="color: #0000ff;">|  1.571 |</span>
<span style="color: #0000ff;">|  0.369 |</span>
<span style="color: #0000ff;">| -0.983 |</span>
<span style="color: #0000ff;">|  0.219 |</span>
<span style="color: #0000ff;">| -1.125 |</span>
<span style="color: #0000ff;">| -1.571 |</span>
<span style="color: #0000ff;">| -0.632 |</span>
</pre>
</div>
<p>
B/c of numerical/computational error you end up with phase shifts for all values - even ones where no signal is present
</p>

<p>
This all illustrates a clear advantage of the Euler complex sinusoidals over real sine/cosine waves. While the magnitude of an equation like A*cos(2&pi;&phi;) changes with <i>&phi;</i>, its corresponding Euler basis vector <i>A&xi;<sup>&phi;</sup></i> will have constant magnitude <i>A</i> for all <i>&phi;</i> (and we just ignore the symmetric mirrored basis vectors that were making the original fluctuate)
</p>

<blockquote>
<p>
<b>Note</b>: While any actual coordinate in the Fourier basis can be broken up into a <i>real</i> and <i>imaginary</i> parts like we did, we can also write it out (like any complex number) in the form <i>Ae<sup>i&theta;</sup></i>. The complex constant/coordinate written in this form is known as the <b>phasor</b>. When multiplied times the basis vector <i>e^[i\omegat}</i> we see that the phasor fully specifies the phase and amplitude of the resulting sine wave in the real/time domain. Operations in the Fourier basis are in effect operations on these phasors.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org75b6ca0" class="outline-3">
<h3 id="org75b6ca0">Which frequencies are observable?</h3>
<div class="outline-text-3" id="text-org75b6ca0">
<p>
When constructing our <i>sine</i> and <i>cosine</i> we noted in passing that <i>&xi;<sup>-&phi;</sup>{} = &xi;<sup>n-&phi;</sup></i> and we notice how each sigular frequency takes up two spots in the coordinate vector - one at <i>&phi;</i> and one at <i>n-&phi;</i>. This is an artifact of our sampling. Regular samples at one frequency will look identical to samples at other frequencies. The problems (and potential advantages) of frequency replication and aliasing <a href="./aliasing.html">are discussed separately</a>
</p>

<p>
In practical terms this means that you can't distinguish <i>&phi;</i> and <i>n-&phi;</i> frequencies, so if you want to use the Fourier basis to look at the spectrum on an input signal you need to ensure <i>n</i> is large enough that all the input frequencies lie between 0 and <i>n/2</i>. Then in the final Fourier basis you can entirely disregard basis vectors from <i>n/2</i> to <i>n</i> b/c they will mirror the <i>0</i> to <i>n/2</i> range.
</p>
<blockquote>
<p>
<b>Note</b> This doesn't represent a loss of information. The input had <b>n</b> real values the output has <b>n/2</b> complex coordinates (each made of 2 values).<br>
<b>Note</b> If the input is complex then this symmertry won't hold. But in most applications a complex input is not meaningful
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org4496499" class="outline-3">
<h3 id="org4496499">How does a frequency who's period isn't a whole fraction of the sample rate come out in this basis?</h3>
<div class="outline-text-3" id="text-org4496499">
<p>
All the previous math had assumed for simplicity that the input was at a frequency that matches one of the basis vectors - that it in effect produced one coordinate point. But how about if <i>&phi;</i> is not equal to a <i>k</i> value?
</p>

<div class="org-src-container">
<pre class="src src-octave">v <span style="color: #483d8b;">=</span> fourierMatrix(n)<span style="color: #483d8b;">'*</span>sin(4.321<span style="color: #483d8b;">*</span>samples <span style="color: #483d8b;">+</span> 2.345)<span style="color: #483d8b;">'</span>
quickRound( abs(v)<span style="color: #483d8b;">'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">| 0.816 | 0.869 | 1.068 | 1.652 | 5.402 | 5.402 | 1.652 | 1.068 | 0.869 |</span>
</pre>
</div>


<ul class="org-ul">
<li>[1 - e<sup>i(w<sub>x</sub>-w<sub>k</sub>)NT</sup>] / [1 - e<sup>i(w<sub>x</sub>-w<sub>k</sub>)T</sup>]</li>
<li>[1 - cos((w<sub>x</sub>-w<sub>k</sub>)NT) + i sin((w<sub>x</sub>-w<sub>k</sub>)NT) ] / [1 - cos((w<sub>x</sub>-w<sub>k</sub>)T) + i sin((w<sub>x</sub>-w<sub>k</sub>)T) ]</li>
</ul>


<ul class="org-ul">
<li>sin() = [ei - e-i]/2i</li>
<li>sin((x-k)NT/2) = [e<sup>i(x-k)NT/2</sup>- e<sup>-i(x-k)NT/2)</sup>]/2i</li>
<li>sin((x-k)T/2) = [e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]/2i</li>
<li>sin((x-k)NT/2)/sin((x-k)T/2)
<ul class="org-ul">
<li>= [e<sup>i(x-k)NT/2</sup>- e<sup>-i(x-k)NT/2)</sup>]/[e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]</li>
</ul></li>
<li>e<sup>i(x-k)(N-1)T/2</sup> * sin((x-k)NT/2)/sin((x-k)T/2)
<ul class="org-ul">
<li>= e<sup>i(x-k)(N-1)T/2</sup> * [e<sup>i(x-k)NT/2</sup>- e<sup>-i(x-k)NT/2)</sup>]/[e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]</li>
<li>= [e<sup>i(x-k)NT/2+i(x-k)(N-1)T/2</sup>- e<sup>-i(x-k)NT/2)+i(x-k)(N-1)T/2</sup>]/[e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]</li>
<li>= [e<sup>i(x-k)T/2*(N+(N-1))</sup>- e<sup>-i(x-k)T/2*(N+(N-1))</sup>]/[e<sup>i(x-k)T/2</sup>- e<sup>-i(x-k)T/2)</sup>]</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</body>
</html>
